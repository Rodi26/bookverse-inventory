name: CI

# DEMO-READY: Automatic triggers enabled for full CI/CD pipeline demonstration
# PRODUCTION NOTE: Real systems would have additional branch protection and approval gates
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: false
        type: boolean

jobs:
  analyze-commit:
    name: "Demo: Analyze Commit (Demo-Optimized)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_app_version }}
      decision_reason: ${{ steps.demo-filter.outputs.decision_reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: "[Demo] Commit Analysis (Optimized for Visibility)"
        id: demo-filter
        env:
          GITHUB_EVENT_INPUTS_FORCE_APP_VERSION: ${{ inputs.force_app_version }}
        run: |
          echo "ðŸŽ¯ DEMO MODE: Analyzing commit for CI/CD pipeline demonstration"
          echo "ðŸ“ Commit: ${GITHUB_SHA:0:8}"
          echo "ðŸ’¬ Message: $(git log -1 --pretty=%B)"
          echo "ðŸ“ Changed files: $(git diff --name-only HEAD~1 | wc -l) files"
          echo "ðŸ­ Production note: Real systems would use conservative defaults"
          echo ""
          
          # Use our commit analysis script
          chmod +x ./scripts/analyze-commit.sh
          ./scripts/analyze-commit.sh

  build-test:
    name: "Build & Test (Always Runs)"
    needs: analyze-commit
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.determine-semver.outputs.app_version }}
      image_tag: ${{ steps.determine-semver.outputs.image_tag }}
      coverage_percent: ${{ steps.test-coverage.outputs.coverage_percent }}
      build_started_timestamp: ${{ steps.export-status-outputs.outputs.build_started_timestamp }}
      docker_build_push_status: ${{ steps.export-status-outputs.outputs.docker_build_push_status }}
      build_info_publish_status: ${{ steps.export-status-outputs.outputs.build_info_publish_status }}
      coverage_evidence_status: ${{ steps.export-status-outputs.outputs.coverage_evidence_status }}
      sast_evidence_status: ${{ steps.export-status-outputs.outputs.sast_evidence_status }}
      quality_evidence_status: ${{ steps.export-status-outputs.outputs.quality_evidence_status }}
      license_evidence_status: ${{ steps.export-status-outputs.outputs.license_evidence_status }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Trigger Information"
        run: |
          echo "ðŸš€ CI Pipeline: Build & Test Phase"
          echo "ðŸ“‹ Commit Analysis Result: ${{ needs.analyze-commit.outputs.commit_type }}"
          echo "ðŸ’¡ Decision: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "ðŸŽ¯ Create App Version: ${{ needs.analyze-commit.outputs.create_app_version }}"
          echo "ðŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ðŸ• Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "SERVICE_NAME=inventory" >> $GITHUB_ENV
          echo "APPLICATION_KEY=bookverse-inventory" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-inventory-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML
          echo "âœ… Python dependencies installed"

      - name: "[Setup] Determine SemVer"
        id: determine-semver
        run: |
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          
          # Get OIDC token from GitHub Actions and exchange for JFrog token
          echo "ðŸ” Exchanging OIDC token for JFrog access token"
          OIDC_TOKEN=$(curl -sLS -H "User-Agent: actions/oidc-client" -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=${{ vars.JFROG_URL }}" | jq -r '.value')
          
          if [[ -z "$OIDC_TOKEN" || "$OIDC_TOKEN" == "null" ]]; then
            echo "âŒ Failed to get OIDC token" >&2
            exit 1
          fi
          
          # Exchange OIDC token for JFrog access token
          JFROG_TOKEN_RESPONSE=$(curl -sS -X POST "${{ vars.JFROG_URL }}/access/api/v1/oidc/token" \
            -H "Content-Type: application/json" \
            -d "{\"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\", \"subject_token\": \"$OIDC_TOKEN\", \"subject_token_type\": \"urn:ietf:params:oauth:token-type:id_token\", \"provider_name\": \"bookverse-inventory-github\"}")
          
          JFROG_TOKEN=$(echo "$JFROG_TOKEN_RESPONSE" | jq -r '.access_token // empty')
          if [[ -z "$JFROG_TOKEN" ]]; then
            echo "âŒ Failed to exchange OIDC token for JFrog token" >&2
            echo "Response: $JFROG_TOKEN_RESPONSE" >&2
            exit 1
          fi
          
          echo "âœ… Successfully obtained JFrog access token via OIDC"
          
          # Use the unified semver determination script
          chmod +x ./scripts/determine-semver.sh
          SEMVER_OUTPUT=$(./scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JFROG_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "$SERVICE_NAME" \
            --verbose)
          
          # Extract APP_VERSION from the Python script's JSON output
          APP_VERSION=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"' | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "âŒ Failed to extract APP_VERSION from semver output" >&2
            exit 1
          fi
          
          # Set IMAGE_TAG to the Docker package tag
          DOCKER_TAG_VAR="DOCKER_TAG_$(echo "$SERVICE_NAME" | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
          if [[ -n "${!DOCKER_TAG_VAR:-}" ]]; then
            IMAGE_TAG="${!DOCKER_TAG_VAR}"
          else
            IMAGE_TAG="$BUILD_NUMBER"
          fi
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: "[Diag] Python deps"
        run: |
          echo "ðŸ”Ž Checking Artifactory connectivity and PyPI virtual repo"
          jf rt ping

      - name: "[Build Info] Collect Python deps"
        run: |
          jf pip-config --repo-resolve "${{ vars.PROJECT_KEY }}-pypi-virtual"
          jf pip install pip\<25 --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"

      - name: "[Test] Install deps"
        run: |
          jf pip-config --repo-resolve "${{ vars.PROJECT_KEY }}-pypi-virtual"
          jf pip install -r requirements.txt --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"

      - name: "[Test] Run with coverage"
        id: test-coverage
        run: |
          echo "ðŸ§ª Running tests with coverage"
          python -m pytest --cov=app --cov-report=xml --cov-report=term-missing
          COVERAGE_PERCENT=$(python -c "import xml.etree.ElementTree as ET; tree = ET.parse('coverage.xml'); root = tree.getroot(); print(f'{float(root.attrib[\"line-rate\"]) * 100:.1f}')")
          echo "ðŸ“Š Coverage: ${COVERAGE_PERCENT}%"
          echo "COVERAGE_PERCENT=$COVERAGE_PERCENT" >> $GITHUB_ENV
          echo "coverage_percent=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT

      - name: "[Build] API image"
        run: |
          jf docker build -t "${{ vars.JFROG_URL }}/${{ vars.PROJECT_KEY }}-${{ env.SERVICE_NAME }}-internal-docker-nonprod-local/${{ env.SERVICE_NAME }}:${{ env.IMAGE_TAG }}" . \
            --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"

      - name: "[Push] API image"
        run: |
          jf docker push "${{ vars.JFROG_URL }}/${{ vars.PROJECT_KEY }}-${{ env.SERVICE_NAME }}-internal-docker-nonprod-local/${{ env.SERVICE_NAME }}:${{ env.IMAGE_TAG }}" \
            --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"
          echo "DOCKER_BUILD_PUSH_STATUS=SUCCESS" >> $GITHUB_ENV

      - name: "[Build Info] Publish"
        run: |
          BUILD_STARTED_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.%3N+0000)
          echo "BUILD_STARTED_TIMESTAMP=$BUILD_STARTED_TIMESTAMP" >> $GITHUB_ENV
          jf rt build-publish "$BUILD_NAME" "$BUILD_NUMBER" --project "${{ vars.PROJECT_KEY }}"
          echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV

      - name: "[Evidence] Prepare coverage template"
        run: |
          echo "ðŸ“„ Preparing coverage template"
          cat > coverage-evidence.template.md <<'EOF'
          # ðŸ“Š Test Coverage Report
          
          > âœ… Coverage: ${COVERAGE_PERCENT}%
          
          This build achieved **${COVERAGE_PERCENT}%** test coverage, meeting our quality standards.
          
          ---
          
          ## Coverage Details
          
          * **Tool**: `pytest-cov`
          * **Coverage**: `${COVERAGE_PERCENT}%`
          * **Threshold**: `60%` (Demo)
          * **Status**: `PASSED`
          * **Generated At (UTC)**: `${NOW_TS}`
          EOF

      - name: "[Evidence] Attach coverage"
        run: |
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > coverage-evidence.json <<JSON
          {
            "testCoverage": {
              "tool": "pytest-cov",
              "coveragePercent": ${COVERAGE_PERCENT},
              "threshold": 60,
              "status": "PASSED",
              "generatedAt": "${NOW_TS}"
            }
          }
          JSON
          export NOW_TS="${NOW_TS}"
          envsubst < coverage-evidence.template.md > coverage-evidence.md
          if jf evd create-evidence \
            --predicate coverage-evidence.json \
            --markdown coverage-evidence.md \
            --predicate-type "https://slsa.dev/evidence/test-coverage/v1" \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"; then
            echo "COVERAGE_EVIDENCE_STATUS=SUCCESS" >> $GITHUB_ENV
          else
            echo "COVERAGE_EVIDENCE_STATUS=FAILED" >> $GITHUB_ENV
            echo "âš ï¸ Coverage evidence attachment failed"
          fi

      - name: "[Evidence] Prepare SAST template"
        run: |
          echo "ðŸ“„ Preparing SAST template"
          cat > sast-evidence.template.md <<'EOF'
          # ðŸ›¡ï¸ SAST Security Scan Report
          
          > âœ… Status: PASSED
          
          Static Application Security Testing completed successfully with no critical vulnerabilities detected.
          
          ---
          
          ## Scan Details
          
          * **Tool**: `Bandit`
          * **Result**: `PASSED`
          * **Critical Issues**: `0`
          * **High Issues**: `0`
          * **Scanned At (UTC)**: `${NOW_TS}`
          EOF

      - name: "[Evidence] Attach SAST"
        run: |
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > sast-evidence.json <<JSON
          {
            "sastScan": {
              "tool": "Bandit",
              "status": "PASSED",
              "criticalIssues": 0,
              "highIssues": 0,
              "scannedAt": "${NOW_TS}"
            }
          }
          JSON
          export NOW_TS="${NOW_TS}"
          envsubst < sast-evidence.template.md > sast-evidence.md
          if jf evd create-evidence \
            --predicate sast-evidence.json \
            --markdown sast-evidence.md \
            --predicate-type "https://slsa.dev/evidence/sast-scan/v1" \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"; then
            echo "SAST_EVIDENCE_STATUS=SUCCESS" >> $GITHUB_ENV
          else
            echo "SAST_EVIDENCE_STATUS=FAILED" >> $GITHUB_ENV
            echo "âš ï¸ SAST evidence attachment failed"
          fi

      - name: "[Evidence] Prepare quality gate"
        run: |
          echo "ðŸ“„ Preparing quality gate template"
          cat > quality-gate.template.md <<'EOF'
          # âœ… Quality Gate Report
          
          > âœ… Status: PASSED
          
          All quality checks have passed successfully.
          
          ---
          
          ## Quality Metrics
          
          * **Tool**: `SonarQube`
          * **Status**: `PASSED`
          * **Coverage**: `${COVERAGE_PERCENT}%`
          * **Checked At (UTC)**: `${NOW_TS}`
          EOF

      - name: "[Evidence] Attach quality gate"
        run: |
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > quality-gate.json <<JSON
          {
            "qualityGate": {
              "tool": "SonarQube",
              "status": "PASSED",
              "checkedAt": "${NOW_TS}"
            }
          }
          JSON
          export NOW_TS="${NOW_TS}"
          envsubst < quality-gate.template.md > quality-gate.md
          if jf evd create-evidence \
            --predicate quality-gate.json \
            --markdown quality-gate.md \
            --predicate-type "https://sonarsource.com/evidence/quality-gate/v1" \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"; then
            echo "QUALITY_EVIDENCE_STATUS=SUCCESS" >> $GITHUB_ENV
          else
            echo "QUALITY_EVIDENCE_STATUS=FAILED" >> $GITHUB_ENV
            echo "âš ï¸ Quality gate evidence attachment failed"
          fi

      - name: "[Evidence] Prepare license template"
        run: |
          echo "ðŸ“„ Preparing license compliance template"
          cat > license-evidence.template.md <<'EOF'
          # ðŸ›¡ï¸ FOSSA License Compliance Report
          
          > âœ… Status: PASSED
          
          All software dependencies are in compliance with the project's license policies.
          
          ---
          
          ## Scan Details
          
          * **Compliance Tool**: `FOSSA`
          * **Result**: `PASSED`
          * **Checked At (UTC)**: `${NOW_TS}`
          EOF

      - name: "[Evidence] Attach license compliance"
        run: |
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > license-evidence.json <<JSON
          {
            "licenseScan": {
              "tool": "FOSSA",
              "status": "PASSED",
              "checkedAt": "${NOW_TS}"
            }
          }
          JSON
          export NOW_TS="${NOW_TS}"
          envsubst < license-evidence.template.md > license-evidence.md
          if jf evd create-evidence \
            --predicate license-evidence.json \
            --markdown license-evidence.md \
            --predicate-type "https://fossa.com/evidence/license-scan/v2.1" \
            --build-name "$BUILD_NAME" \
            --build-number "$BUILD_NUMBER" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"; then
            echo "LICENSE_EVIDENCE_STATUS=SUCCESS" >> $GITHUB_ENV
          else
            echo "LICENSE_EVIDENCE_STATUS=FAILED" >> $GITHUB_ENV
            echo "âš ï¸ License compliance evidence attachment failed"
          fi

      - name: "[Evidence] Export statuses"
        id: export-status-outputs
        run: |
          echo "docker_build_push_status=${DOCKER_BUILD_PUSH_STATUS:-UNKNOWN}" >> $GITHUB_OUTPUT
          echo "build_info_publish_status=${BUILD_INFO_PUBLISH_STATUS:-UNKNOWN}" >> $GITHUB_OUTPUT
          echo "build_started_timestamp=${BUILD_STARTED_TIMESTAMP:-UNKNOWN}" >> $GITHUB_OUTPUT
          echo "coverage_evidence_status=${COVERAGE_EVIDENCE_STATUS:-UNKNOWN}" >> $GITHUB_OUTPUT
          echo "sast_evidence_status=${SAST_EVIDENCE_STATUS:-UNKNOWN}" >> $GITHUB_OUTPUT
          echo "quality_evidence_status=${QUALITY_EVIDENCE_STATUS:-UNKNOWN}" >> $GITHUB_OUTPUT
          echo "license_evidence_status=${LICENSE_EVIDENCE_STATUS:-UNKNOWN}" >> $GITHUB_OUTPUT

      - name: "[Summary] Build Complete"
        run: |
          echo "### ðŸŽ¯ Demo CI/CD Pipeline: Build & Test Phase Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### ðŸ“‹ Commit Analysis Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Decision**: ${{ needs.analyze-commit.outputs.decision_reason }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit Type**: ${{ needs.analyze-commit.outputs.commit_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Create App Version**: ${{ needs.analyze-commit.outputs.create_app_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### âœ… Build & Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Coverage**: ${{ steps.test-coverage.outputs.coverage_percent }}%" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Build**: ${{ env.DOCKER_BUILD_PUSH_STATUS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Info**: ${{ env.BUILD_INFO_PUBLISH_STATUS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Evidence Collection**: Package/Build evidence attached" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.analyze-commit.outputs.create_app_version }}" == "true" ]]; then
            echo "#### ðŸš€ Next Phase" >> $GITHUB_STEP_SUMMARY
            echo "- **Application Version Creation**: Will proceed automatically" >> $GITHUB_STEP_SUMMARY
            echo "- **Evidence**: Application-level evidence will be attached" >> $GITHUB_STEP_SUMMARY
          else
            echo "#### ðŸ”¨ Pipeline Complete" >> $GITHUB_STEP_SUMMARY
            echo "- **Build Info Only**: No application version will be created" >> $GITHUB_STEP_SUMMARY
            echo "- **Traceability**: Build info published for tracking" >> $GITHUB_STEP_SUMMARY
          fi

  create-promote:
    name: "Create Application Version & Promote (Conditional)"
    needs: [analyze-commit, build-test]
    if: ${{ needs.analyze-commit.outputs.create_app_version == 'true' }}
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Application Version Creation"
        run: |
          echo "ðŸš€ CI Pipeline: Application Version Creation Phase"
          echo "ðŸ“‹ Commit Analysis: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "ðŸŽ¯ App Version: ${{ needs.build-test.outputs.app_version }}"
          echo "ðŸ·ï¸ Image Tag: ${{ needs.build-test.outputs.image_tag }}"
          echo "ðŸ‘¤ Triggered by: ${{ github.actor }}"

      - name: "[Setup] Inherit Variables"
        run: |
          echo "SERVICE_NAME=inventory" >> $GITHUB_ENV
          echo "APPLICATION_KEY=bookverse-inventory" >> $GITHUB_ENV
          echo "BUILD_NAME=${{ needs.build-test.outputs.build_name }}" >> $GITHUB_ENV
          echo "BUILD_NUMBER=${{ needs.build-test.outputs.build_number }}" >> $GITHUB_ENV
          echo "APP_VERSION=${{ needs.build-test.outputs.app_version }}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ needs.build-test.outputs.image_tag }}" >> $GITHUB_ENV
          echo "BUILD_STARTED_TIMESTAMP=${{ needs.build-test.outputs.build_started_timestamp }}" >> $GITHUB_ENV
          echo "BUILD_INFO_REPO=${{ vars.PROJECT_KEY }}-build-info" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI (OIDC Re-auth)"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-inventory-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Setup] Get OIDC Token for Application Creation"
        run: |
          # Get OIDC token from GitHub Actions and exchange for JFrog token
          echo "ðŸ” Exchanging OIDC token for JFrog access token (Application Creation)"
          OIDC_TOKEN=$(curl -sLS -H "User-Agent: actions/oidc-client" -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=${{ vars.JFROG_URL }}" | jq -r '.value')
          
          if [[ -z "$OIDC_TOKEN" || "$OIDC_TOKEN" == "null" ]]; then
            echo "âŒ Failed to get OIDC token" >&2
            exit 1
          fi
          
          # Exchange OIDC token for JFrog access token
          JFROG_TOKEN_RESPONSE=$(curl -sS -X POST "${{ vars.JFROG_URL }}/access/api/v1/oidc/token" \
            -H "Content-Type: application/json" \
            -d "{\"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\", \"subject_token\": \"$OIDC_TOKEN\", \"subject_token_type\": \"urn:ietf:params:oauth:token-type:id_token\", \"provider_name\": \"bookverse-inventory-github\"}")
          
          JF_OIDC_TOKEN=$(echo "$JFROG_TOKEN_RESPONSE" | jq -r '.access_token // empty')
          if [[ -z "$JF_OIDC_TOKEN" ]]; then
            echo "âŒ Failed to exchange OIDC token for JFrog token" >&2
            echo "Response: $JFROG_TOKEN_RESPONSE" >&2
            exit 1
          fi
          
          echo "âœ… Successfully obtained JFrog access token via OIDC"
          echo "JF_OIDC_TOKEN=$JF_OIDC_TOKEN" >> $GITHUB_ENV

      - name: "[Release] Create application version"
        run: |
          echo "ðŸš€ Creating AppTrust application version: $APP_VERSION"
          
          # Determine application version tag - simulate real development environment
          # Array of realistic single tags for demo
          TAG_OPTIONS=(
            "release"
            "hotfix"
            "feature"
            "bugfix"
            "enhancement"
            "security"
            "performance"
            "refactor"
            "experimental"
            "maintenance"
            "integration"
            "documentation"
            "stable"
            "beta"
            "alpha"
            "critical"
            "patch"
            "minor"
            "major"
            "cleanup"
          )
          
          # Randomly select single tag based on run number for consistency
          TAG_INDEX=$((${{ github.run_number }} % ${#TAG_OPTIONS[@]}))
          APP_TAG="${TAG_OPTIONS[$TAG_INDEX]}"
          echo "ðŸ·ï¸ Application Version Tag (demo simulation): $APP_TAG"
          
          # Create application version with build sources (simplified single-line JSON)
          if [[ -n "$BUILD_STARTED_TIMESTAMP" ]]; then
            echo "âœ… Using actual build timestamp: $BUILD_STARTED_TIMESTAMP"
            APP_VERSION_PAYLOAD="{\"version\":\"$APP_VERSION\",\"tag\":\"$APP_TAG\",\"sources\":{\"builds\":[{\"name\":\"$BUILD_NAME\",\"number\":\"$BUILD_NUMBER\",\"repository_key\":\"$BUILD_INFO_REPO\",\"include_dependencies\":true,\"started\":\"$BUILD_STARTED_TIMESTAMP\"}]}}"
          else
            echo "âš ï¸ No build timestamp available, omitting from payload"  
            APP_VERSION_PAYLOAD="{\"version\":\"$APP_VERSION\",\"tag\":\"$APP_TAG\",\"sources\":{\"builds\":[{\"name\":\"$BUILD_NAME\",\"number\":\"$BUILD_NUMBER\",\"repository_key\":\"$BUILD_INFO_REPO\",\"include_dependencies\":true}]}}"
          fi
          
          # Debug: show sanitized curl and payload
          echo "ðŸ“¦ Application Key: $APPLICATION_KEY"
          echo "ðŸ“ Payload:"; echo "$APP_VERSION_PAYLOAD" | jq . || echo "$APP_VERSION_PAYLOAD"
          
          # Create application version (capture HTTP status + body)
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          JF_URL='${{ vars.JFROG_URL }}'
          PROJECT='${{ vars.PROJECT_KEY }}'
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "âŒ Missing JF_OIDC_TOKEN in environment. Ensure OIDC token exchange succeeded." >&2; exit 1; fi
          
          RESP_FILE=$(mktemp)
          CODE=$(curl -sS -L -X POST "$JF_URL/apptrust/api/v1/applications/$APPLICATION_KEY/versions?async=false" \
            -H "Authorization: Bearer $JF_OIDC_TOKEN" \
            -H "X-JFrog-Project: $PROJECT" \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -d "$APP_VERSION_PAYLOAD" -o "$RESP_FILE" -w "%{http_code}" || echo 000)
          echo "ðŸ“¨ Response Body:"; cat "$RESP_FILE" || true; echo
          if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]] || ! jq -e . >/dev/null 2>&1 < "$RESP_FILE"; then
            echo "âŒ Failed to create application version (HTTP $CODE)" >&2
            rm -f "$RESP_FILE"; exit 1
          fi
          
          echo "âœ… Application version created: $APPLICATION_KEY@$APP_VERSION"
          echo "ðŸ“¦ Packages will be automatically bound from build sources"
          rm -f "$RESP_FILE"

      - name: "[Evidence] Prepare Application Templates"
        run: |
          echo "ðŸ“„ Preparing SLSA and Jira templates"
          cat > slsa-evidence.template.md <<'EOF'
          # ðŸ” SLSA Provenance Report
          
          > âœ… SLSA Level: 2
          
          This application version meets SLSA Level 2 requirements for supply chain security.
          
          ---
          
          ## Provenance Details
          
          * **SLSA Level**: `2`
          * **Builder**: `GitHub Actions`
          * **Source Repository**: `${{ github.repository }}`
          * **Commit SHA**: `${{ github.sha }}`
          * **Generated At (UTC)**: `${NOW_TS}`
          EOF
          
          cat > jira-evidence.template.md <<'EOF'
          # ðŸŽ« Jira Release Notes
          
          > âœ… Status: APPROVED
          
          This release has been reviewed and approved through our change management process.
          
          ---
          
          ## Release Information
          
          * **Release Version**: `${APP_VERSION}`
          * **Approval Status**: `APPROVED`
          * **Change Tickets**: `DEMO-123, DEMO-456`
          * **Approved At (UTC)**: `${NOW_TS}`
          EOF

      - name: "[Evidence] Attach Application Evidence (SLSA, Jira)"
        run: |
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # SLSA Evidence
          cat > slsa-evidence.json <<JSON
          {
            "slsaProvenance": {
              "level": 2,
              "builder": "GitHub Actions",
              "sourceRepository": "${{ github.repository }}",
              "commitSha": "${{ github.sha }}",
              "generatedAt": "${NOW_TS}"
            }
          }
          JSON
          export NOW_TS="${NOW_TS}"
          export APP_VERSION="${APP_VERSION}"
          envsubst < slsa-evidence.template.md > slsa-evidence.md
          jf evd create-evidence \
            --predicate slsa-evidence.json \
            --markdown slsa-evidence.md \
            --predicate-type "https://slsa.dev/provenance/v1" \
            --application-key "$APPLICATION_KEY" \
            --application-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}" || echo "âš ï¸ SLSA evidence failed"
          
          # Jira Evidence
          cat > jira-evidence.json <<JSON
          {
            "changeManagement": {
              "tool": "Jira",
              "releaseVersion": "${APP_VERSION}",
              "approvalStatus": "APPROVED",
              "changeTickets": ["DEMO-123", "DEMO-456"],
              "approvedAt": "${NOW_TS}"
            }
          }
          JSON
          envsubst < jira-evidence.template.md > jira-evidence.md
          jf evd create-evidence \
            --predicate jira-evidence.json \
            --markdown jira-evidence.md \
            --predicate-type "https://atlassian.com/evidence/change-management/v1" \
            --application-key "$APPLICATION_KEY" \
            --application-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}" || echo "âš ï¸ Jira evidence failed"

      - name: "[Summary] Application Version Complete"
        run: |
          echo "### ðŸŽ¯ Demo CI/CD Pipeline: Application Version Creation Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### âœ… Application Version Created" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: \`$APPLICATION_KEY\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: \`$APP_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Sources**: Automatically bound from build info" >> $GITHUB_STEP_SUMMARY
          echo "- **Evidence**: Application-level evidence attached (SLSA, Jira)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### ðŸ”— References" >> $GITHUB_STEP_SUMMARY
          echo "- Project: \`${{ vars.PROJECT_KEY }}\` on \`${{ vars.JFROG_URL }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- AppTrust Application Version: \`$APPLICATION_KEY@$APP_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- Build Info: \`$BUILD_NAME#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**âœ… Application version prepared and ready for governance and promotion to DEV.**" >> $GITHUB_STEP_SUMMARY