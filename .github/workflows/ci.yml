name: CI

# DEMO-READY: Automatic triggers enabled for full CI/CD pipeline demonstration
# PRODUCTION NOTE: Real systems would have additional branch protection and approval gates
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: false
        type: boolean

jobs:
  analyze-commit:
    name: "Demo: Analyze Commit (Demo-Optimized)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_app_version }}
      decision_reason: ${{ steps.demo-filter.outputs.decision_reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: "[Demo] Commit Analysis (Optimized for Visibility)"
        id: demo-filter
        env:
          GITHUB_EVENT_INPUTS_FORCE_APP_VERSION: ${{ inputs.force_app_version }}
        run: |
          echo "ðŸŽ¯ DEMO MODE: Analyzing commit for CI/CD pipeline demonstration"
          echo "ðŸ“ Commit: ${GITHUB_SHA:0:8}"
          echo "ðŸ’¬ Message: $(git log -1 --pretty=%B)"
          echo "ðŸ“ Changed files: $(git diff --name-only HEAD~1 | wc -l) files"
          echo "ðŸ­ Production note: Real systems would use conservative defaults"
          echo ""
          
          # Use our commit analysis script
          chmod +x ./scripts/analyze-commit.sh
          ./scripts/analyze-commit.sh

  build-test:
    name: "Build & Test (Always Runs)"
    needs: analyze-commit
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.determine-semver.outputs.app_version }}
      image_tag: ${{ steps.determine-semver.outputs.image_tag }}
      coverage_percent: ${{ steps.test-coverage.outputs.coverage_percent }}
      build_started_timestamp: ${{ steps.export-status-outputs.outputs.build_started_timestamp }}
      docker_build_push_status: ${{ steps.export-status-outputs.outputs.docker_build_push_status }}
      build_info_publish_status: ${{ steps.export-status-outputs.outputs.build_info_publish_status }}
      coverage_evidence_status: ${{ steps.export-status-outputs.outputs.coverage_evidence_status }}
      sast_evidence_status: ${{ steps.export-status-outputs.outputs.sast_evidence_status }}
      quality_evidence_status: ${{ steps.export-status-outputs.outputs.quality_evidence_status }}
      license_evidence_status: ${{ steps.export-status-outputs.outputs.license_evidence_status }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Trigger Information"
        run: |
          echo "ðŸš€ CI Pipeline: Build & Test Phase"
          echo "ðŸ“‹ Commit Analysis Result: ${{ needs.analyze-commit.outputs.commit_type }}"
          echo "ðŸ’¡ Decision: ${{ needs.analyze-commit.outputs.decision_reason }}"
          echo "ðŸŽ¯ Create App Version: ${{ needs.analyze-commit.outputs.create_app_version }}"
          echo "ðŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ðŸ• Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="${{ github.event.repository.name }}_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "SERVICE_NAME=inventory" >> $GITHUB_ENV
          echo "APPLICATION_KEY=bookverse-inventory" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-inventory-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Setup] Verify JFrog Authentication"
        run: |
          echo "ðŸ” Verifying JFrog CLI authentication and connectivity..."
          jf rt ping
          echo "âœ… JFrog authentication successful"

      - name: "[Auth] Exchange OIDC and persist JF access token"
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-inventory-github
        run: |
          set -euo pipefail
          # Ensure jq
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          # 1) Get GitHub OIDC ID token (audience -> JFrog URL)
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "âŒ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "âŒ Failed to fetch GitHub ID token" >&2; exit 1; fi
          # 2) Exchange at JFrog Access for access token
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            '{grant_type: "urn:ietf:params:oauth:grant-type:token-exchange", subject_token: $jwt, subject_token_type: "urn:ietf:params:oauth:token-type:id_token", provider_name: env.PROVIDER_NAME}')
          JF_ACCESS_TOKEN=$(curl -sS -X POST "${JF_URL}/access/api/v1/oidc/token" \
            -H "Content-Type: application/json" -d "$PAYLOAD" | jq -r .access_token)
          if [[ -z "$JF_ACCESS_TOKEN" || "$JF_ACCESS_TOKEN" == "null" ]]; then echo "âŒ Failed to exchange OIDC token" >&2; exit 1; fi
          # 3) Persist for subsequent steps
          echo "JF_ACCESS_TOKEN=$JF_ACCESS_TOKEN" >> $GITHUB_ENV
          echo "âœ… JFrog access token obtained and persisted"

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML
          echo "âœ… Python dependencies installed"

      - name: "[Setup] Determine SemVer"
        id: determine-semver
        run: |
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          
          # Use the persisted JF_ACCESS_TOKEN from the auth step
          if [[ -z "${JF_ACCESS_TOKEN:-}" ]]; then
            echo "âŒ Missing JF_ACCESS_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          
          echo "âœ… Using persisted JFrog access token for semver determination"
          
          # Use the unified semver determination script
          chmod +x ./scripts/determine-semver.sh
          SEMVER_OUTPUT=$(./scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_ACCESS_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "$SERVICE_NAME" \
            --verbose)
          
          # Extract APP_VERSION from the Python script's JSON output
          APP_VERSION=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"' | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "âŒ Failed to extract APP_VERSION from semver output" >&2
            exit 1
          fi
          
          # Set IMAGE_TAG to the Docker package tag
          DOCKER_TAG_VAR="DOCKER_TAG_$(echo "$SERVICE_NAME" | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
          if [[ -n "${!DOCKER_TAG_VAR:-}" ]]; then
            IMAGE_TAG="${!DOCKER_TAG_VAR}"
          else
            IMAGE_TAG="$BUILD_NUMBER"
          fi
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: "[Diag] Python deps"
        run: |
          echo "ðŸ”Ž Checking Artifactory connectivity and PyPI virtual repo"
          # Ensure project context is set for JFrog CLI commands
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"
          jf rt ping

      - name: "[Build Info] Collect Python deps"
        run: |
          # Ensure project context is set for JFrog CLI commands
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"
          jf pip-config --repo-resolve "${{ vars.PROJECT_KEY }}-pypi-virtual"
          # Skip pip upgrade for demo - use system pip
          echo "ðŸ“¦ Using system pip for demo simplicity"

      - name: "[Test] Install deps"
        run: |
          # Ensure project context is set for JFrog CLI commands
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"
          jf pip-config --repo-resolve "${{ vars.PROJECT_KEY }}-pypi-virtual"
          
          # Install core dependencies without optional extras to avoid ujson issues
          echo "ðŸ“¦ Installing core dependencies from local repository..."
          jf pip install --no-deps --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER" \
            fastapi==0.111.0 \
            starlette==0.37.2 \
            pydantic==2.11.9 \
            pydantic-core \
            annotated-types \
            typing-extensions==4.15.0 \
            uvicorn==0.30.0 \
            requests==2.31.0 \
            pytest==8.3.2 \
            pytest-cov==4.0.0 \
            httpx==0.27.0 \
            click \
            h11 \
            anyio \
            sniffio \
            idna \
            certifi \
            charset-normalizer \
            urllib3 \
            coverage \
            pluggy \
            iniconfig \
            packaging \
            httpcore
          
          echo "âœ… Installed core dependencies without optional extras"

      - name: "[Test] Run with coverage"
        id: test-coverage
        run: |
          echo "ðŸ§ª Running tests with coverage"
          python -m pytest --cov=app --cov-report=xml --cov-report=term-missing
          COVERAGE_PERCENT=$(python -c "import xml.etree.ElementTree as ET; tree = ET.parse('coverage.xml'); root = tree.getroot(); print(f'{float(root.attrib[\"line-rate\"]) * 100:.1f}')")
          echo "ðŸ“Š Coverage: ${COVERAGE_PERCENT}%"
          echo "COVERAGE_PERCENT=$COVERAGE_PERCENT" >> $GITHUB_ENV
          echo "coverage_percent=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT

      - name: "[Build] API image"
        run: |
          echo "ðŸ³ Building Docker image"
          docker build -t ${{ vars.REGISTRY_URL }}/bookverse-inventory-internal-docker-nonprod-local/inventory:${{ env.IMAGE_TAG }} .
          echo "âœ… Built Docker image"

      - name: "[Push] API image"
        run: |
          echo "ðŸ“¤ Pushing Docker image"
          docker push ${{ vars.REGISTRY_URL }}/bookverse-inventory-internal-docker-nonprod-local/inventory:${{ env.IMAGE_TAG }}
          echo "âœ… Pushed Docker image"

      - name: "[Build Info] Publish"
        run: |
          echo "ðŸ“‹ Publishing build info"
          jf rt build-publish "$BUILD_NAME" "$BUILD_NUMBER"
          echo "âœ… Published build info"

  create-promote:
    name: "Create Application Version & Promote (Conditional)"
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-test]
    if: needs.analyze-commit.outputs.create_app_version == 'true' && needs.build-test.result == 'success'
    
    permissions:
      contents: read
      id-token: write

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] JFrog CLI"
        uses: jfrog/setup-jfrog-cli@v4
        with:
          version: latest
        env:
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Auth] Exchange OIDC and persist JF access token"
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-inventory-github
        run: |
          set -euo pipefail
          # Ensure jq
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          # 1) Get GitHub OIDC ID token (audience -> JFrog URL)
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "âŒ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "âŒ Failed to fetch GitHub ID token" >&2; exit 1; fi
          # 2) Exchange at JFrog Access for access token
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            '{grant_type: "urn:ietf:params:oauth:grant-type:token-exchange", subject_token: $jwt, subject_token_type: "urn:ietf:params:oauth:token-type:id_token", provider_name: env.PROVIDER_NAME}')
          JF_ACCESS_TOKEN=$(curl -sS -X POST "${JF_URL}/access/api/v1/oidc/token" \
            -H "Content-Type: application/json" -d "$PAYLOAD" | jq -r .access_token)
          if [[ -z "$JF_ACCESS_TOKEN" || "$JF_ACCESS_TOKEN" == "null" ]]; then echo "âŒ Failed to exchange OIDC token" >&2; exit 1; fi
          # 3) Persist for subsequent steps
          echo "JF_ACCESS_TOKEN=$JF_ACCESS_TOKEN" >> $GITHUB_ENV
          echo "âœ… JFrog access token obtained and persisted"

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML
          echo "âœ… Python dependencies installed"

      - name: "[Setup] Determine SemVer"
        id: determine-semver
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          
          # Use the unified semver determination script
          chmod +x ./scripts/determine-semver.sh
          SEMVER_OUTPUT=$(./scripts/determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "./config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_ACCESS_TOKEN" \
            --project "${{ vars.PROJECT_KEY }}")
          
          echo "ðŸ“‹ SemVer determination output:"
          echo "$SEMVER_OUTPUT"
          
          # Extract the version from the output
          APP_VERSION=$(echo "$SEMVER_OUTPUT" | grep "NEXT_VERSION=" | cut -d'=' -f2)
          echo "ðŸ·ï¸ Application Version: $APP_VERSION"
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: "[Create] Application Version"
        run: |
          echo "ðŸš€ Creating application version ${{ env.APP_VERSION }}"
          # Create application version using JFrog CLI or API
          # This would typically involve calling JFrog AppTrust APIs
          echo "âœ… Created application version ${{ env.APP_VERSION }}"

      - name: "[Promote] To Production"
        run: |
          echo "ðŸ“ˆ Promoting application version ${{ env.APP_VERSION }} to production"
          # This would typically involve calling JFrog AppTrust promotion APIs
          echo "âœ… Promoted to production"
