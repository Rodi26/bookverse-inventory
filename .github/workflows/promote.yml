name: Promote

on:
  workflow_dispatch:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: choice
        options: [ DEV, QA, STAGING, PROD ]
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string

jobs:
  promote:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve application and version
        run: |
          set -euo pipefail
          SERVICE_NAME=$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          TARGET_STAGE=${{ inputs.target_stage }}
          APP_VERSION_INPUT="${{ inputs.application_version }}"
          APP_VERSION=""
          if [ -n "$APP_VERSION_INPUT" ]; then
            APP_VERSION="$APP_VERSION_INPUT"
          else
            echo "üîé Fetching latest application version for $APPLICATION_KEY"
            RESP_FILE=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_FILE" -w "%{http_code}" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?limit=1&order_by=created&order_asc=false" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "Accept: application/json")
            if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
              if LATEST_VERSION=$(jq -er '.versions[0].version // empty' "$RESP_FILE" 2>/dev/null); then
                APP_VERSION="$LATEST_VERSION"
              fi
            fi
            rm -f "$RESP_FILE"
            if [ -z "$APP_VERSION" ]; then
              echo "‚ùå Could not determine latest application version for $APPLICATION_KEY" >&2
              exit 1
            fi
          fi
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "TARGET_STAGE=$TARGET_STAGE" >> $GITHUB_ENV

      - name: Setup JFrog CLI (for evidence attachments)
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: github-bookverse-inventory
          disable-job-summary: true
          oidc-audience: jfrog-github

      - name: Prepare evidence signing keys (optional)
        run: |
          set -euo pipefail
          if [[ -n "${{ secrets.EVIDENCE_PRIVATE_KEY }}" ]]; then
            umask 077
            printf "%s" "${{ secrets.EVIDENCE_PRIVATE_KEY }}" > evidence_private.pem
            KEY_ALIAS="${{ vars.EVIDENCE_KEY_ALIAS || 'BookVerse-Evidence-Key' }}"
            echo "EVIDENCE_SIGN_ARGS=--key evidence_private.pem --key-alias ${KEY_ALIAS} --provider-id github-actions" >> $GITHUB_ENV
          else
            echo "EVIDENCE_SIGN_ARGS=" >> $GITHUB_ENV
          fi

      - name: Promote application version across SDLC to PROD (chain)
        run: |
          set -euo pipefail
          echo "üì¶ Application: $APPLICATION_KEY"
          echo "üè∑Ô∏è Version: $APP_VERSION"
          
          # Discover current stage and release status
          SUMMARY_BODY=$(mktemp)
          SUMMARY_CODE=$(curl -sS -L -o "$SUMMARY_BODY" -w "%{http_code}" \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION" \
            -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -H "Accept: application/json")
          if [[ "$SUMMARY_CODE" -lt 200 || "$SUMMARY_CODE" -ge 300 ]]; then
            echo "‚ùå Failed to fetch version summary (HTTP $SUMMARY_CODE)" >&2
            cat "$SUMMARY_BODY" || true
            rm -f "$SUMMARY_BODY"
            exit 1
          fi
          CURRENT_STAGE=$(jq -r '.current_stage // empty' "$SUMMARY_BODY" 2>/dev/null || echo "")
          RELEASE_STATUS=$(jq -r '.release_status // empty' "$SUMMARY_BODY" 2>/dev/null || echo "")
          rm -f "$SUMMARY_BODY"
          CS_UPPER=$(echo "$CURRENT_STAGE" | tr '[:lower:]' '[:upper:]')
          echo "üîé Current stage: ${CURRENT_STAGE:-UNASSIGNED} (release_status=${RELEASE_STATUS:-unknown})"
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE:-UNASSIGNED}" >> $GITHUB_ENV
          echo "RELEASE_STATUS_BEFORE=${RELEASE_STATUS:-UNKNOWN}" >> $GITHUB_ENV
          
          # Plan remaining chain
          STAGES=(DEV QA STAGING)
          CHAIN=()
          case "$CS_UPPER" in
            ""|"UNASSIGNED") CHAIN=(DEV QA STAGING) ;;
            "DEV")            CHAIN=(QA STAGING) ;;
            "QA")             CHAIN=(STAGING) ;;
            "STAGING")        CHAIN=() ;;
            "PROD")           CHAIN=() ;;
            *)                 CHAIN=(DEV QA STAGING) ;;
          esac
          
          PROMOTED_STAGES=""
          for STG in "${CHAIN[@]}"; do
            echo "üöÄ Promoting to $STG via AppTrust"
            RESP_BODY=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/promote?async=false" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "{\"target_stage\": \"$STG\", \"promotion_type\": \"copy\"}")
            echo "HTTP $HTTP_STATUS"; cat "$RESP_BODY" || true; echo
            rm -f "$RESP_BODY"
            if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
              echo "‚ùå Promotion to $STG failed" >&2
              exit 1
            fi
            PROMOTED_STAGES="$PROMOTED_STAGES${PROMOTED_STAGES:+ }$STG"
          done
          echo "PROMOTED_STAGES=$PROMOTED_STAGES" >> $GITHUB_ENV
          
          # Release to PROD if not already released
          DID_RELEASE=false
          if [[ "$RELEASE_STATUS" != "RELEASED" && "$RELEASE_STATUS" != "TRUSTED_RELEASE" ]]; then
            echo "üöÄ Releasing to PROD via AppTrust Release API"
            RESP_BODY=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/release?async=false" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d '{"promotion_type":"copy"}')
            echo "HTTP $HTTP_STATUS"; cat "$RESP_BODY" || true; echo
            rm -f "$RESP_BODY"
            if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
              echo "‚ùå Release to PROD failed" >&2
              exit 1
            fi
            DID_RELEASE=true
          else
            echo "‚ÑπÔ∏è Version already released (status=$RELEASE_STATUS). Skipping release call."
          fi
          echo "DID_RELEASE=$DID_RELEASE" >> $GITHUB_ENV

      - name: Attach QA gate evidence (Invicti DAST, Postman API) if in QA
        run: |
          set -euo pipefail
          # Determine if QA was reached in this run
          REACHED_QA=false
          if echo "${PROMOTED_STAGES:-}" | grep -qw QA; then REACHED_QA=true; fi
          if [[ "$REACHED_QA" != true ]]; then
            echo "‚ÑπÔ∏è QA not reached; skipping QA gate evidence"
            exit 0
          fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          # Invicti DAST (QA)
          SCAN_ID=$(cat /proc/sys/kernel/random/uuid)
          MED=$((2 + RANDOM % 5))
          cat <<EOF > dast-qa.json
          {
            "environment": "QA",
            "scanId": "${SCAN_ID}",
            "status": "PASSED",
            "findings": { "critical": 0, "high": 0, "medium": ${MED} },
            "attachStage": "QA", "gateForPromotionTo": "STAGING",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate dast-qa.json \
            --predicate-type "https://invicti.com/evidence/dast/v3" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è DAST (QA) attachment failed"
          # Postman API (QA)
          COLL=$(cat /proc/sys/kernel/random/uuid)
          PASS=$((100 + RANDOM % 31))
          cat <<EOF > postman-qa.json
          {
            "environment": "QA",
            "collectionId": "${COLL}",
            "status": "PASSED",
            "assertionsPassed": ${PASS},
            "assertionsFailed": 0,
            "attachStage": "QA", "gateForPromotionTo": "STAGING",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate postman-qa.json \
            --predicate-type "https://postman.com/evidence/collection/v2.2" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è Postman (QA) attachment failed"

      - name: Attach STAGING gate evidence (Snyk IaC, Cobalt, ServiceNow) if in STAGING
        run: |
          set -euo pipefail
          REACHED_STAGING=false
          if echo "${PROMOTED_STAGES:-}" | grep -qw STAGING; then REACHED_STAGING=true; fi
          if [[ "$REACHED_STAGING" != true ]]; then
            echo "‚ÑπÔ∏è STAGING not reached; skipping STAGING gate evidence"
            exit 0
          fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          # Snyk IaC (STAGING)
          MED=$((1 + RANDOM % 3)); LOW=$((8 + RANDOM % 7))
          cat <<EOF > iac-staging.json
          {
            "environment": "STAGING", "status": "PASSED",
            "misconfigurations": { "high": 0, "medium": ${MED}, "low": ${LOW} },
            "attachStage": "STAGING", "gateForPromotionTo": "PROD",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate iac-staging.json \
            --predicate-type "https://snyk.io/evidence/iac/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è IaC (STAGING) attachment failed"
          # Cobalt Pentest (STAGING)
          PENT=$(cat /proc/sys/kernel/random/uuid)
          cat <<EOF > pentest-staging.json
          {
            "environment": "STAGING", "pentestId": "${PENT}",
            "status": "COMPLETED", "summary": "No critical/high. Medium/low scheduled for remediation.",
            "attachStage": "STAGING", "gateForPromotionTo": "PROD",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate pentest-staging.json \
            --predicate-type "https://cobalt.io/evidence/pentest/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è Pentest (STAGING) attachment failed"
          # ServiceNow change approval (STAGING gate to PROD)
          TID=$((3000000 + RANDOM % 1000000))
          cat <<EOF > servicenow-approval.json
          {
            "environment": "PROD",
            "ticketId": "CHG${TID}",
            "status": "APPROVED",
            "approvedBy": "change-manager-${RANDOM}",
            "approvalTimestamp": "${NOW_TS}",
            "attachStage": "STAGING", "gateForPromotionTo": "PROD"
          }
          EOF
          jf evd create \
            --predicate servicenow-approval.json \
            --predicate-type "https://servicenow.com/evidence/change-request/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è ServiceNow approval attachment failed"

      - name: Attach ArgoCD deployment evidence (PROD verification) if released
        run: |
          set -euo pipefail
          if [[ "${DID_RELEASE}" != "true" ]]; then
            echo "‚ÑπÔ∏è Not released in this run; skipping ArgoCD PROD verification"
            exit 0
          fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          REV="${{ github.sha }}"; SHORT=${REV:0:8}
          cat <<EOF > argocd-prod.json
          { "tool": "ArgoCD", "status": "Synced", "revision": "${SHORT}", "deployedAt": "${NOW_TS}", "attachStage": "PROD" }
          EOF
          jf evd create \
            --predicate argocd-prod.json \
            --predicate-type "https://argoproj.github.io/argo-cd/evidence/deployment/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è ArgoCD PROD verification attachment failed"

      - name: Generate promotion summary
        run: |
          echo "## üöÄ AppTrust Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìÑ Evidence Plan: see bookverse-demo-init/docs/EVIDENCE_PLAN.md" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** $APPLICATION_KEY" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $APP_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Started at:** ${CURRENT_STAGE_BEFORE}" >> $GITHUB_STEP_SUMMARY
          echo "**Promoted stages:** ${PROMOTED_STAGES:-none}" >> $GITHUB_STEP_SUMMARY
          echo "**Released to PROD:** ${DID_RELEASE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Promotions flow: UNASSIGNED ‚Üí DEV ‚Üí QA ‚Üí STAGING ‚Üí (Release) PROD" >> $GITHUB_STEP_SUMMARY


