name: Promote

on:
  workflow_dispatch:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: choice
        default: 'PROD'
        options: [ PROD, STAGING, QA, DEV ]
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string

jobs:
  promote:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve application and version
        run: |
          set -euo pipefail
          SERVICE_NAME=$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          TARGET_STAGE=${{ inputs.target_stage }}
          APP_VERSION_INPUT="${{ inputs.application_version }}"
          APP_VERSION=""
          if [ -n "$APP_VERSION_INPUT" ]; then
            APP_VERSION="$APP_VERSION_INPUT"
          else
            echo "🔎 Fetching latest application version for $APPLICATION_KEY"
            RESP_FILE=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_FILE" -w "%{http_code}" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?limit=1&order_by=created&order_asc=false" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "Accept: application/json")
            if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
              if LATEST_VERSION=$(jq -er '.versions[0].version // empty' "$RESP_FILE" 2>/dev/null); then
                APP_VERSION="$LATEST_VERSION"
              fi
            fi
            rm -f "$RESP_FILE"
            if [ -z "$APP_VERSION" ]; then
              echo "❌ Could not determine latest application version for $APPLICATION_KEY" >&2
              exit 1
            fi
          fi
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "TARGET_STAGE=$TARGET_STAGE" >> $GITHUB_ENV

      - name: Setup JFrog CLI (for evidence attachments)
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: github-bookverse-inventory
          disable-job-summary: true
          oidc-audience: jfrog-github

      - name: Prepare evidence signing keys (optional)
        run: |
          set -euo pipefail
          if [[ -n "${{ secrets.EVIDENCE_PRIVATE_KEY }}" ]]; then
            umask 077
            printf "%s" "${{ secrets.EVIDENCE_PRIVATE_KEY }}" > evidence_private.pem
            KEY_ALIAS="${{ vars.EVIDENCE_KEY_ALIAS || 'BookVerse-Evidence-Key' }}"
            echo "EVIDENCE_SIGN_ARGS=--key evidence_private.pem --key-alias ${KEY_ALIAS} --provider-id github-actions" >> $GITHUB_ENV
          else
            echo "EVIDENCE_SIGN_ARGS=" >> $GITHUB_ENV
          fi

      - name: Promote application version across SDLC to PROD (chain)
        run: |
          set -euo pipefail
          # HTTP_DEBUG_LEVEL can be set at repo or project vars: none|basic|verbose
          if [[ -n "${{ vars.HTTP_DEBUG_LEVEL }}" ]]; then export HTTP_DEBUG_LEVEL="${{ vars.HTTP_DEBUG_LEVEL }}"; fi
          echo "📦 Application: $APPLICATION_KEY"
          echo "🏷️ Version: $APP_VERSION"
          
          # Single source of truth for summary – define once and reuse
          # Source shared debug helper (if present)
          if [ -f .github/scripts/http_debug.sh ]; then source .github/scripts/http_debug.sh; fi
          # Fallback minimal debug function (respects HTTP_DEBUG_LEVEL)
          if ! declare -f print_request_debug >/dev/null 2>&1; then
            print_request_debug() {
              local method="$1"; local url="$2"; local body="${3:-}"; local level="${HTTP_DEBUG_LEVEL:-basic}"
              [ "$level" = "none" ] && return 0
              echo "---- Request debug (${level}) ----"; echo "Method: ${method}"; echo "URL: ${url}"; echo "Headers:"; echo "  Authorization: Bearer ***REDACTED***"; echo "  X-JFrog-Project: ${{ vars.PROJECT_KEY }}"; echo "  Accept: application/json"; echo "-----------------------"
            }
          fi

          fetch_summary() {
            local body
            body=$(mktemp)
            local code
            code=$(curl -sS -L -o "$body" -w "%{http_code}" \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION" \
            -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -H "Accept: application/json")
            if [[ "$code" -ge 200 && "$code" -lt 300 ]]; then
              CURRENT_STAGE=$(jq -r '.current_stage // empty' "$body" 2>/dev/null || echo "")
              RELEASE_STATUS=$(jq -r '.release_status // empty' "$body" 2>/dev/null || echo "")
            else
              echo "❌ Failed to fetch version summary (HTTP $code)" >&2
              print_request_debug "GET" "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION"
              cat "$body" || true
              rm -f "$body"
            exit 1
          fi
            rm -f "$body"
          echo "🔎 Current stage: ${CURRENT_STAGE:-UNASSIGNED} (release_status=${RELEASE_STATUS:-unknown})"
          }
          # Initial state snapshot
          fetch_summary
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE:-UNASSIGNED}" >> $GITHUB_ENV
          echo "RELEASE_STATUS_BEFORE=${RELEASE_STATUS:-UNKNOWN}" >> $GITHUB_ENV
          
          # Resolve lifecycle order dynamically (bookverse-lifecycle by default)
          LIFECYCLE_NAME="${{ vars.LIFECYCLE_NAME }}"
          if [[ -z "$LIFECYCLE_NAME" ]]; then LIFECYCLE_NAME='bookverse-lifecycle'; fi
          LC_FILE=$(mktemp)
          # Access API: list lifecycles for project, then select by name
          CODE=$(curl -sS -L -o "$LC_FILE" -w "%{http_code}" "${{ vars.JFROG_URL }}/access/api/v2/lifecycle/?project_key=${{ vars.PROJECT_KEY }}" \
            -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
            -H "Accept: application/json" || echo 000)
          if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]]; then
            echo "❌ Failed to fetch lifecycles list for project '${{ vars.PROJECT_KEY }}' (HTTP $CODE)" >&2
            print_request_debug "GET" "${{ vars.JFROG_URL }}/access/api/v2/lifecycle/?project_key=${{ vars.PROJECT_KEY }}"
            cat "$LC_FILE" || true
            rm -f "$LC_FILE"
            exit 1
          fi
          # Extract stage names and the declared releaseStage (case-sensitive)
          NAMES=$(jq -r --arg n "$LIFECYCLE_NAME" '.[] | select(.name == $n) | .stages[] | (if type=="object" then .name else . end)' "$LC_FILE" 2>/dev/null || true)
          RELEASE_STAGE=$(jq -r --arg n "$LIFECYCLE_NAME" '.[] | select(.name == $n) | (.releaseStage // empty)' "$LC_FILE" 2>/dev/null || true)
          rm -f "$LC_FILE"
          STAGES=()
          while IFS= read -r line; do [[ -n "$line" ]] && STAGES+=("$line"); done < <(printf "%s\n" "$NAMES")
          if [[ ${#STAGES[@]} -eq 0 ]]; then
            echo "❌ Lifecycle '$LIFECYCLE_NAME' not found or has no stages for project '${{ vars.PROJECT_KEY }}'" >&2
            exit 1
          fi
          # Prefer lifecycle.releaseStage as the final stage; fallback to last stage for safety
          if [[ -n "$RELEASE_STAGE" ]]; then
            FINAL_STAGE="$RELEASE_STAGE"
          else
          FINAL_STAGE="${STAGES[$((${#STAGES[@]}-1))]}"
          fi
          echo "FINAL_STAGE=$FINAL_STAGE" >> $GITHUB_ENV
          # Compute indices (case-sensitive)
          CURRENT_INDEX=-1
          for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]}" == "$CURRENT_STAGE" ]]; then CURRENT_INDEX=$i; break; fi; done
          TS_INPUT="${{ inputs.target_stage }}"
          TARGET_NAME="$TS_INPUT"
          if [[ -z "$TARGET_NAME" ]]; then TARGET_NAME="$FINAL_STAGE"; fi
          TARGET_INDEX=-1
          for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]}" == "$TARGET_NAME" ]]; then TARGET_INDEX=$i; break; fi; done
          if [[ "$TARGET_INDEX" -lt 0 ]]; then
            echo "❌ Target stage '$TARGET_NAME' not found in lifecycle. Available: ${STAGES[*]}" >&2
            exit 1
          fi
          # If current unknown/unassigned, start before first stage
          if [[ "$CURRENT_INDEX" -lt 0 ]]; then CURRENT_INDEX=-1; fi
          if [[ "$CURRENT_INDEX" -ge "$TARGET_INDEX" ]]; then
            echo "ℹ️ Current stage ($CURRENT_STAGE) is at or beyond target ($TARGET_NAME). Nothing to promote."
            echo "PROMOTED_STAGES=" >> $GITHUB_ENV
            echo "DID_RELEASE=false" >> $GITHUB_ENV
            exit 0
          fi
          
          PROMOTED_STAGES=""
          DID_RELEASE=false
          
          # HTTP helper for AppTrust POST calls
          apptrust_post() {
            local path="$1"; local data="$2"; local out_file="$3"
            local status
            status=$(curl -sS -L -o "$out_file" -w "%{http_code}" -X POST \
              "${{ vars.JFROG_URL }}$path" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "$data")
            echo "$status"
          }

          promote_to_stage() {
            local target_stage="$1"
            echo "🚀 Promoting to $target_stage via AppTrust"
            local resp_body http_status
            resp_body=$(mktemp)
            http_status=$(apptrust_post \
              "/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/promote?async=false" \
              "{\"target_stage\": \"$target_stage\", \"promotion_type\": \"copy\"}" \
              "$resp_body")
            echo "HTTP $http_status"; cat "$resp_body" || true; echo
            rm -f "$resp_body"
            if [[ "$http_status" -lt 200 || "$http_status" -ge 300 ]]; then
              echo "❌ Promotion to $target_stage failed (HTTP $http_status)" >&2
              print_request_debug "POST" "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/promote?async=false" "{\"target_stage\": \"$target_stage\", \"promotion_type\": \"copy\"}"
              exit 1
            fi
            PROMOTED_STAGES="$PROMOTED_STAGES${PROMOTED_STAGES:+ }$target_stage"
            fetch_summary
          }

          release_version() {
              echo "🚀 Releasing to $FINAL_STAGE via AppTrust Release API"
            local resp_body http_status
            resp_body=$(mktemp)
            http_status=$(apptrust_post \
              "/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/release?async=false" \
              '{"promotion_type":"copy"}' \
              "$resp_body")
            echo "HTTP $http_status"; cat "$resp_body" || true; echo
            rm -f "$resp_body"
            if [[ "$http_status" -lt 200 || "$http_status" -ge 300 ]]; then
              echo "❌ Release to $FINAL_STAGE failed (HTTP $http_status)" >&2
              print_request_debug "POST" "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/release?async=false" '{"promotion_type":"copy"}'
                exit 1
              fi
              DID_RELEASE=true
              PROMOTED_STAGES="$PROMOTED_STAGES${PROMOTED_STAGES:+ }$FINAL_STAGE"
            fetch_summary
          }

          # Evidence helpers per stage
          emit_json() {
            # emit_json <file> <json_string>
            local out_file="$1"; shift
            local content="$*"
            cat <<EOF > "$out_file"
            $content
            EOF
          }

          evd_create() {
            # evd_create <file> <type>
            local predicate_file="$1"; local predicate_type="$2"
            jf evd create \
              --predicate "$predicate_file" \
              --predicate-type "$predicate_type" \
              --release-bundle "$APPLICATION_KEY" \
              --release-bundle-version "$APP_VERSION" \
              --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || true
          }

          attach_evidence_qa() {
            local now_ts scan_id med coll pass
            now_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            # Invicti DAST (QA)
            scan_id=$(cat /proc/sys/kernel/random/uuid)
            med=$((2 + RANDOM % 5))
            emit_json dast-qa.json "{
              \"environment\": \"QA\",
              \"scanId\": \"${scan_id}\",
              \"status\": \"PASSED\",
              \"findings\": { \"critical\": 0, \"high\": 0, \"medium\": ${med} },
              \"attachStage\": \"QA\", \"gateForPromotionTo\": \"STAGING\",
              \"timestamp\": \"${now_ts}\"
            }"
            evd_create dast-qa.json "https://invicti.com/evidence/dast/v3"
            # Postman API (QA)
            coll=$(cat /proc/sys/kernel/random/uuid)
            pass=$((100 + RANDOM % 31))
            emit_json postman-qa.json "{
              \"environment\": \"QA\",
              \"collectionId\": \"${coll}\",
              \"status\": \"PASSED\",
              \"assertionsPassed\": ${pass},
              \"assertionsFailed\": 0,
              \"attachStage\": \"QA\", \"gateForPromotionTo\": \"STAGING\",
              \"timestamp\": \"${now_ts}\"
            }"
            evd_create postman-qa.json "https://postman.com/evidence/collection/v2.2"
          }

          attach_evidence_staging() {
            local now_ts med_iac low_iac pent tid
            now_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            # Snyk IaC (STAGING)
            med_iac=$((1 + RANDOM % 3)); low_iac=$((8 + RANDOM % 7))
            emit_json iac-staging.json "{
              \"environment\": \"STAGING\", \"status\": \"PASSED\",
              \"misconfigurations\": { \"high\": 0, \"medium\": ${med_iac}, \"low\": ${low_iac} },
              \"attachStage\": \"STAGING\", \"gateForPromotionTo\": \"PROD\",
              \"timestamp\": \"${now_ts}\"
            }"
            evd_create iac-staging.json "https://snyk.io/evidence/iac/v1"
            # Cobalt Pentest (STAGING)
            pent=$(cat /proc/sys/kernel/random/uuid)
            emit_json pentest-staging.json "{
              \"environment\": \"STAGING\", \"pentestId\": \"${pent}\",
              \"status\": \"COMPLETED\", \"summary\": \"No critical/high. Medium/low scheduled for remediation.\",
              \"attachStage\": \"STAGING\", \"gateForPromotionTo\": \"PROD\",
              \"timestamp\": \"${now_ts}\"
            }"
            evd_create pentest-staging.json "https://cobalt.io/evidence/pentest/v1"
            # ServiceNow change approval (STAGING gate to PROD)
            tid=$((3000000 + RANDOM % 1000000))
            emit_json servicenow-approval.json "{
              \"environment\": \"PROD\",
              \"ticketId\": \"CHG${tid}\",
              \"status\": \"APPROVED\",
              \"approvedBy\": \"change-manager-${RANDOM}\",
              \"approvalTimestamp\": \"${now_ts}\",
              \"attachStage\": \"STAGING\", \"gateForPromotionTo\": \"PROD\"
            }"
            evd_create servicenow-approval.json "https://servicenow.com/evidence/change-request/v1"
          }

          attach_evidence_prod() {
            local now_ts rev short
            now_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            # ArgoCD deployment evidence (PROD verification)
            rev="${{ github.sha }}"; short=${rev:0:8}
            emit_json argocd-prod.json "{ \"tool\": \"ArgoCD\", \"status\": \"Synced\", \"revision\": \"${short}\", \"deployedAt\": \"${now_ts}\", \"attachStage\": \"PROD\" }"
            evd_create argocd-prod.json "https://argoproj.github.io/argo-cd/evidence/deployment/v1"
          }

          attach_evidence_for() {
            local stage_name="$1"
            case "$stage_name" in
              UNASSIGNED)
                echo "ℹ️ No evidence for UNASSIGNED" ;;
              DEV)
                echo "ℹ️ No evidence configured for DEV in demo" ;;
              QA)
                attach_evidence_qa ;;
              STAGING)
                attach_evidence_staging ;;
              PROD)
                attach_evidence_prod ;;
              *)
                echo "ℹ️ No evidence rule for stage '$stage_name'" ;;
            esac
          }

          promote_or_release_and_attach() {
            local next_stage="$1"
            if [[ "$next_stage" == "$FINAL_STAGE" ]]; then
              release_version
              attach_evidence_prod
            else
              promote_to_stage "$next_stage"
              attach_evidence_for "$next_stage"
            fi
          }

          # Determine next stage and execute a single promotion step
          CURRENT_INDEX=-1
          for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]}" == "$CURRENT_STAGE" ]]; then CURRENT_INDEX=$i; break; fi; done
          if [[ "$CURRENT_INDEX" -lt 0 ]]; then CURRENT_INDEX=-1; fi
          NEXT_INDEX=$((CURRENT_INDEX+1))
          if [[ "$NEXT_INDEX" -gt "$TARGET_INDEX" ]]; then
            echo "ℹ️ Next stage would exceed target ($TARGET_NAME). Nothing to promote."
            echo "PROMOTED_STAGES=$PROMOTED_STAGES" >> $GITHUB_ENV
            echo "DID_RELEASE=$DID_RELEASE" >> $GITHUB_ENV
            exit 0
          fi
          NEXT_STAGE="${STAGES[$NEXT_INDEX]}"

          case "${CURRENT_STAGE:-UNASSIGNED}" in
            ""|UNASSIGNED|DEV|QA|STAGING)
              promote_or_release_and_attach "$NEXT_STAGE" ;;
            PROD)
              echo "ℹ️ Already at PROD; nothing to promote" ;;
            *)
              promote_or_release_and_attach "$NEXT_STAGE" ;;
          esac

          echo "PROMOTED_STAGES=$PROMOTED_STAGES" >> $GITHUB_ENV
          echo "DID_RELEASE=$DID_RELEASE" >> $GITHUB_ENV
          # Final verification for this step
          if [[ "$NEXT_STAGE" == "$FINAL_STAGE" ]]; then
            if [[ "$RELEASE_STATUS" != "RELEASED" && "$RELEASE_STATUS" != "TRUSTED_RELEASE" ]]; then
              echo "❌ Verification failed: expected release, got current_stage=${CURRENT_STAGE:-unknown} release_status=${RELEASE_STATUS:-unknown}" >&2
              exit 1
            fi
          else
            if [[ "$CURRENT_STAGE" != "$NEXT_STAGE" ]]; then
              echo "❌ Verification failed: expected $NEXT_STAGE, got ${CURRENT_STAGE:-unknown}" >&2
              exit 1
            fi
          fi


      - name: Generate promotion summary
        run: |
          echo "## 🚀 AppTrust Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📄 Evidence Plan: see bookverse-demo-init/docs/EVIDENCE_PLAN.md" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** $APPLICATION_KEY" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $APP_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Started at:** ${CURRENT_STAGE_BEFORE}" >> $GITHUB_STEP_SUMMARY
          echo "**Promoted stages:** ${PROMOTED_STAGES:-none}" >> $GITHUB_STEP_SUMMARY
          echo "**Released to ${FINAL_STAGE}:** ${DID_RELEASE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Lifecycle final stage: ${FINAL_STAGE}" >> $GITHUB_STEP_SUMMARY


