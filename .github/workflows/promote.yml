name: Promote

on:
  workflow_dispatch:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: choice
        default: 'PROD'
        options: [ PROD, STAGING, QA, DEV ]
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string
      DEMO_MODE:
        description: 'Enable demo mode (verbose logs, request tracing)'
        required: false
        default: 'false'
        type: choice
        options: ['false', 'true']
      service_name:
        description: 'Service name override (optional)'
        required: false
        type: string
      oidc_provider_name:
        description: 'OIDC provider name for jfrog/setup-jfrog-cli'
        required: false
        type: string
        default: 'bookverse-inventory-github'
      evidence_key_alias:
        description: 'Evidence key alias (optional)'
        required: false
        type: string
  workflow_call:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: string
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string
      DEMO_MODE:
        description: 'Enable demo mode (verbose logs, request tracing)'
        required: false
        type: string
        default: 'false'
      service_name:
        description: 'Service name (e.g., inventory, checkout, recommendations, web)'
        required: false
        type: string
      oidc_provider_name:
        description: 'OIDC provider name for jfrog/setup-jfrog-cli'
        required: false
        type: string
      evidence_key_alias:
        description: 'Evidence key alias (if server-side aliasing is used)'
        required: false
        type: string

jobs:
  promote:
    name: Promote
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      DEMO_MODE: "false"

    # Evidence signing configuration:
    # - secrets.EVIDENCE_PRIVATE_KEY: private key material (sensitive)
    # - vars.EVIDENCE_KEY_ALIAS: non-secret alias passed to --key-alias
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] DEMO_MODE default"
        run: |
          echo "DEMO_MODE=${DEMO_MODE:-false}" >> $GITHUB_ENV

      - name: "[Setup] DEMO_MODE"
        if: ${{ inputs.DEMO_MODE == 'true' || env.DEMO_MODE == 'true' }}
        run: |
          echo "üîî DEMO_MODE enabled"
          echo "ACTIONS_STEP_DEBUG=true" >> $GITHUB_ENV
          echo "ACTIONS_RUNNER_DEBUG=true" >> $GITHUB_ENV
          echo "HTTP_DEBUG_LEVEL=verbose" >> $GITHUB_ENV
          echo "BASH_XTRACE_ENABLED=1" >> $GITHUB_ENV
          echo "LOG_LEVEL=DEBUG" >> $GITHUB_ENV

      - name: "[Resolve] App & version"
        run: |
          set -euo pipefail
          SERVICE_NAME=$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          TARGET_STAGE=${{ inputs.target_stage }}
          APP_VERSION_INPUT="${{ inputs.application_version }}"
          APP_VERSION=""
          if [ -n "$APP_VERSION_INPUT" ]; then
            APP_VERSION="$APP_VERSION_INPUT"
          else
            echo "üîé Fetching latest application version for $APPLICATION_KEY"
            RESP_FILE=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_FILE" -w "%{http_code}" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?limit=1&order_by=created&order_asc=false" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "Accept: application/json")
            if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
              if LATEST_VERSION=$(jq -er '.versions[0].version // empty' "$RESP_FILE" 2>/dev/null); then
                APP_VERSION="$LATEST_VERSION"
              fi
            fi
            rm -f "$RESP_FILE"
            if [ -z "$APP_VERSION" ]; then
              echo "‚ùå Could not determine latest application version for $APPLICATION_KEY" >&2
              exit 1
            fi
          fi
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "TARGET_STAGE=$TARGET_STAGE" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-inventory-github
          disable-job-summary: true
          oidc-audience: ${{ vars.JFROG_URL }}

      - name: "[Setup] Promotion context"
        run: |
          set -euo pipefail
          # This step resolves lifecycle, establishes CURRENT_STAGE, and prepares
          # variables consumed by promote_lib.sh. See promote_lib.sh header docs
          # for how advance_one_step orchestrates promote vs release.
          if [[ -n "${HTTP_DEBUG_LEVEL:-}" ]]; then :; else export HTTP_DEBUG_LEVEL=basic; fi
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          export JFROG_ADMIN_TOKEN="${{ secrets.JFROG_ADMIN_TOKEN }}"
          source .github/scripts/promote_lib.sh
          echo "üì¶ Application: $APPLICATION_KEY"
          echo "üè∑Ô∏è Version: $APP_VERSION"
          fetch_summary
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE:-UNASSIGNED}" >> $GITHUB_ENV
          echo "RELEASE_STATUS_BEFORE=${RELEASE_STATUS:-UNKNOWN}" >> $GITHUB_ENV
          LC_FILE=$(mktemp)
          CODE=$(curl -sS -L -o "$LC_FILE" -w "%{http_code}" "$JFROG_URL/access/api/v2/lifecycle/?project_key=$PROJECT_KEY" -H "Authorization: Bearer $JFROG_ADMIN_TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]]; then
            echo "‚ùå Failed to fetch lifecycles list for project '$PROJECT_KEY' (HTTP $CODE)" >&2
            print_request_debug "GET" "$JFROG_URL/access/api/v2/lifecycle/?project_key=$PROJECT_KEY"
            cat "$LC_FILE" || true
            rm -f "$LC_FILE"
            exit 1
          fi
          NORM_FILE=$(mktemp)
          jq -c 'if type=="array" then . elif has("lifecycles") then .lifecycles elif has("items") then .items elif has("results") then .results elif (has("name") and has("stages")) then [.] else [] end' "$LC_FILE" > "$NORM_FILE" 2>/dev/null || printf '[]' > "$NORM_FILE"
          rm -f "$LC_FILE"
          LIFECYCLE_NAME="${LIFECYCLE_NAME:-bookverse-lifecycle}"
          NAMES=$(jq -r --arg n "$LIFECYCLE_NAME" 'map(select(.name == $n)) | .[0].stages // [] | map(if type=="object" then .name else . end) | .[]' "$NORM_FILE" 2>/dev/null || true)
          RELEASE_STAGE=$(jq -r --arg n "$LIFECYCLE_NAME" '([ .[] | select(.name == $n) | .releaseStage ] | .[0]) // empty' "$NORM_FILE" 2>/dev/null || true)
          STAGES=()
          while IFS= read -r orig; do
            [[ -z "$orig" ]] && continue
            display=$(display_stage_for "$orig")
            STAGES+=("$display")
          done < <(printf "%s\n" "$NAMES")
          rm -f "$NORM_FILE"
          if [[ ${#STAGES[@]} -eq 0 ]]; then
            echo "‚ÑπÔ∏è Lifecycle '$LIFECYCLE_NAME' not found; falling back to default stages (DEV ‚Üí QA ‚Üí STAGING ‚Üí PROD)" >&2
            STAGES=(DEV QA STAGING PROD)
          fi
          if [[ -n "$RELEASE_STAGE" ]]; then
            FINAL_STAGE=$(display_stage_for "$RELEASE_STAGE")
          else
            FINAL_STAGE="${STAGES[$((${#STAGES[@]}-1))]}"
          fi
          echo "FINAL_STAGE=$FINAL_STAGE" >> $GITHUB_ENV
          STAGES_STR="${STAGES[*]}"
          echo "STAGES_STR=$STAGES_STR" >> $GITHUB_ENV
          TS_INPUT="${{ inputs.target_stage }}"
          TARGET_NAME="$TS_INPUT"
          if [[ -z "$TARGET_NAME" ]]; then TARGET_NAME="$FINAL_STAGE"; fi
          echo "TARGET_NAME=$TARGET_NAME" >> $GITHUB_ENV
            echo "PROMOTED_STAGES=" >> $GITHUB_ENV
            echo "DID_RELEASE=false" >> $GITHUB_ENV
          PROMO_SUMMARY_FILE=$(mktemp)
          echo "PROMO_SUMMARY_FILE=$PROMO_SUMMARY_FILE" >> $GITHUB_ENV
          {
            echo "### üß≠ Stage-by-stage execution (expected vs actual)"
            echo ""
          } >> "$PROMO_SUMMARY_FILE"

      - name: "[Promote] UNASSIGNED ‚Üí next"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          # Single-step progression; if CURRENT_STAGE is UNASSIGNED, this will
          # move to the first lifecycle stage. Release is never attempted here.
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          export JFROG_ADMIN_TOKEN="${{ secrets.JFROG_ADMIN_TOKEN }}"
          source .github/scripts/promote_lib.sh
          fetch_summary
          # Compute expectation
          CURR_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
          IFS=' ' read -r -a STAGES <<< "${STAGES_STR:-}"
          EXPECTED_NEXT="${STAGES[0]:-UNKNOWN}"
          echo "PROMO_UNASSIGNED_EXPECTED=$EXPECTED_NEXT" >> $GITHUB_ENV
          if [[ -z "${CURRENT_STAGE:-}" || "$CURR_DISPLAY" == "UNASSIGNED" ]]; then
            echo "PROMO_UNASSIGNED_ATTEMPTED=true" >> $GITHUB_ENV
            ALLOW_RELEASE=false
            set +e
            advance_one_step
            RC=$?
            set -e
            fetch_summary
            AFTER_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
            STATUS="FAILED"
            if [[ "$RC" -eq 0 && "$AFTER_DISPLAY" == "$EXPECTED_NEXT" ]]; then STATUS="SUCCESS"; fi
            echo "PROMO_UNASSIGNED_ACTUAL=$AFTER_DISPLAY" >> $GITHUB_ENV
            echo "PROMO_UNASSIGNED_STATUS=$STATUS" >> $GITHUB_ENV
            {
              echo "- UNASSIGNED ‚Üí ${EXPECTED_NEXT}: should promote; actual at ${AFTER_DISPLAY} ‚Äî ${STATUS}"
            } >> "$PROMO_SUMMARY_FILE"
          else
            echo "PROMO_UNASSIGNED_ATTEMPTED=false" >> $GITHUB_ENV
            {
              echo "- UNASSIGNED: skipped (current=${CURR_DISPLAY})"
            } >> "$PROMO_SUMMARY_FILE"
          fi

      - name: "[Promote] DEV ‚Üí next"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          # From DEV, advance to QA (no release). Evidence for QA gates is
          # attached by the library immediately after promote.
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          export JFROG_ADMIN_TOKEN="${{ secrets.JFROG_ADMIN_TOKEN }}"
          source .github/scripts/promote_lib.sh
            fetch_summary
          CURR_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
          IFS=' ' read -r -a STAGES <<< "${STAGES_STR:-}"
          # Find next after DEV
          EXPECTED_NEXT="UNKNOWN"
          for ((i=0; i<${#STAGES[@]}; i++)); do
            if [[ "${STAGES[$i]}" == "DEV" && $i -lt $((${#STAGES[@]}-1)) ]]; then EXPECTED_NEXT="${STAGES[$i+1]}"; fi
          done
          echo "PROMO_DEV_EXPECTED=$EXPECTED_NEXT" >> $GITHUB_ENV
          if [[ "$CURR_DISPLAY" == "DEV" ]]; then
            echo "PROMO_DEV_ATTEMPTED=true" >> $GITHUB_ENV
            ALLOW_RELEASE=false
            set +e
            advance_one_step
            RC=$?
            set -e
            fetch_summary
            AFTER_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
            STATUS="FAILED"
            if [[ "$RC" -eq 0 && "$AFTER_DISPLAY" == "$EXPECTED_NEXT" ]]; then STATUS="SUCCESS"; fi
            echo "PROMO_DEV_ACTUAL=$AFTER_DISPLAY" >> $GITHUB_ENV
            echo "PROMO_DEV_STATUS=$STATUS" >> $GITHUB_ENV
            {
              echo "- DEV ‚Üí ${EXPECTED_NEXT}: should promote; actual at ${AFTER_DISPLAY} ‚Äî ${STATUS}"
            } >> "$PROMO_SUMMARY_FILE"
          else
            echo "PROMO_DEV_ATTEMPTED=false" >> $GITHUB_ENV
            {
              echo "- DEV: skipped (current=${CURR_DISPLAY})"
            } >> "$PROMO_SUMMARY_FILE"
          fi

      - name: "[Promote] QA ‚Üí next"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          # From QA, advance to STAGING (no release). QA gate evidence is
          # attached during this transition.
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          export JFROG_ADMIN_TOKEN="${{ secrets.JFROG_ADMIN_TOKEN }}"
          source .github/scripts/promote_lib.sh
            fetch_summary
          CURR_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
          IFS=' ' read -r -a STAGES <<< "${STAGES_STR:-}"
          # Find next after QA
          EXPECTED_NEXT="UNKNOWN"
          for ((i=0; i<${#STAGES[@]}; i++)); do
            if [[ "${STAGES[$i]}" == "QA" && $i -lt $((${#STAGES[@]}-1)) ]]; then EXPECTED_NEXT="${STAGES[$i+1]}"; fi
          done
          echo "PROMO_QA_EXPECTED=$EXPECTED_NEXT" >> $GITHUB_ENV
          if [[ "$CURR_DISPLAY" == "QA" ]]; then
            echo "PROMO_QA_ATTEMPTED=true" >> $GITHUB_ENV
            ALLOW_RELEASE=false
            set +e
            advance_one_step
            RC=$?
            set -e
            fetch_summary
            AFTER_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
            STATUS="FAILED"
            if [[ "$RC" -eq 0 && "$AFTER_DISPLAY" == "$EXPECTED_NEXT" ]]; then STATUS="SUCCESS"; fi
            echo "PROMO_QA_ACTUAL=$AFTER_DISPLAY" >> $GITHUB_ENV
            echo "PROMO_QA_STATUS=$STATUS" >> $GITHUB_ENV
            {
              echo "- QA ‚Üí ${EXPECTED_NEXT}: should promote; actual at ${AFTER_DISPLAY} ‚Äî ${STATUS}"
            } >> "$PROMO_SUMMARY_FILE"
          else
            echo "PROMO_QA_ATTEMPTED=false" >> $GITHUB_ENV
            {
              echo "- QA: skipped (current=${CURR_DISPLAY})"
            } >> "$PROMO_SUMMARY_FILE"
          fi

      - name: "[Promote] STAGING ‚Üí next"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          # From STAGING, advance_one_step would attempt release if allowed.
          # We defer release to the dedicated step below by keeping
          # ALLOW_RELEASE=false here.
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          export JFROG_ADMIN_TOKEN="${{ secrets.JFROG_ADMIN_TOKEN }}"
          source .github/scripts/promote_lib.sh
          fetch_summary
          CURR_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
          IFS=' ' read -r -a STAGES <<< "${STAGES_STR:-}"
          # Expected next is the element after STAGING (usually PROD)
          EXPECTED_NEXT="UNKNOWN"
          for ((i=0; i<${#STAGES[@]}; i++)); do
            if [[ "${STAGES[$i]}" == "STAGING" && $i -lt $((${#STAGES[@]}-1)) ]]; then EXPECTED_NEXT="${STAGES[$i+1]}"; fi
          done
          echo "PROMO_STAGING_EXPECTED=$EXPECTED_NEXT" >> $GITHUB_ENV
          if [[ "$CURR_DISPLAY" == "STAGING" ]]; then
            echo "PROMO_STAGING_ATTEMPTED=true" >> $GITHUB_ENV
            ALLOW_RELEASE=false
            set +e
            advance_one_step
            RC=$?
            set -e
            fetch_summary
            AFTER_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
            STATUS="FAILED"
            if [[ "$RC" -eq 0 && "$AFTER_DISPLAY" == "$EXPECTED_NEXT" ]]; then STATUS="SUCCESS"; fi
            echo "PROMO_STAGING_ACTUAL=$AFTER_DISPLAY" >> $GITHUB_ENV
            echo "PROMO_STAGING_STATUS=$STATUS" >> $GITHUB_ENV
            {
              echo "- STAGING ‚Üí ${EXPECTED_NEXT}: should promote (no release); actual at ${AFTER_DISPLAY} ‚Äî ${STATUS}"
            } >> "$PROMO_SUMMARY_FILE"
          else
            echo "PROMO_STAGING_ATTEMPTED=false" >> $GITHUB_ENV
            {
              echo "- STAGING: skipped (current=${CURR_DISPLAY})"
            } >> "$PROMO_SUMMARY_FILE"
          fi

      - name: "[Evidence] Decide STAGING"
        id: decide-staging
        run: |
          set -euo pipefail
          # PROMOTED_STAGES is space-separated, CURRENT_STAGE is API form (e.g., bookverse-STAGING)
          PS="${PROMOTED_STAGES:-}"
          CS="${CURRENT_STAGE:-}"
          attach="false"
          if echo " $PS " | grep -q " STAGING "; then attach="true"; fi
          if [[ "$CS" == *"-STAGING" || "$CS" == "STAGING" ]]; then attach="true"; fi
          echo "attach=$attach" >> $GITHUB_OUTPUT

      - name: "[Evidence] Prepare STAGING templates"
        if: ${{ steps.decide-staging.outputs.attach == 'true' }}
        run: |
          set -euo pipefail
          # We use quoted here-docs (<<'EOF') to prevent the shell from expanding
          # variables or command substitutions while creating templates. This keeps
          # a clean, literal template that we populate later with envsubst.

          # IaC template
          cat > iac-evidence.template.md <<'EOF'
          # Snyk IaC Scan

          **Scan Tool:** Snyk IaC  
          **Scan Date:** ${NOW_TS}  
          **Repository:** ${{ github.repository }}  
          **Commit:** ${{ github.sha }}

          ## Summary
          - Critical: 0
          - High: 1
          - Medium: 2
          - Low: 3

          > Infrastructure-as-Code configuration findings for STAGING gate.
          EOF

          # Pentest template
          cat > pentest-evidence.template.md <<'EOF'
          # Cobalt.io Pentest Summary

          **Engagement ID:** ${ENG_ID}  
          **Completed:** ${NOW_TS}

          ## Findings
          - Total: 1
          - Critical: 0
          - High: 0
          - Medium: 1
          - Low: 0

          > External penetration test summary attached for STAGING gate.
          EOF

          # Change approval template
          cat > change-approval.template.md <<'EOF'
          # ServiceNow Change Approval

          **Change ID:** ${CHG_ID}  
          **Status:** Approved  
          **Approved By:** ${APPROVER}  
          **Approved At:** ${NOW_TS}

          > Managerial approval for release promotion from STAGING to PROD.
          EOF

      - name: "[Evidence] Attach STAGING"
        if: ${{ steps.decide-staging.outputs.attach == 'true' }}
        run: |
          set -euo pipefail
          # Export variables and use envsubst to safely substitute values into templates
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          export NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          export ENG_ID="ENG-$(( (${GITHUB_RUN_NUMBER:-0} + ${GITHUB_RUN_ATTEMPT:-0}) % 9000 + 1000 ))"
          export CHG_ID="CHG-$(( (${GITHUB_RUN_NUMBER:-0} * 10 + ${GITHUB_RUN_ATTEMPT:-0}) ))"
          export APPROVER="user-${GITHUB_ACTOR}-${GITHUB_RUN_ATTEMPT:-1}"

          # IaC predicate and markdown
          cat > iac-evidence.json <<JSON
          {
            "iacScan": {
              "tool": "Snyk",
              "scanDate": "${NOW_TS}",
              "summary": { "critical": 0, "high": 1, "medium": 2, "low": 3 },
              "repository": "${{ github.repository }}",
              "commit": "${{ github.sha }}"
            }
          }
          JSON
          envsubst < iac-evidence.template.md > iac-evidence.md
          if jf evd create-evidence \
            --predicate iac-evidence.json \
            --markdown iac-evidence.md \
            --predicate-type "https://snyk.io/evidence/iac/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"; then
            IAC_EVIDENCE_STATUS=SUCCESS
          else
            IAC_EVIDENCE_STATUS=FAILED
          fi
          echo "IAC_EVIDENCE_STATUS=$IAC_EVIDENCE_STATUS" >> $GITHUB_ENV

          # Pentest predicate and markdown
          cat > pentest-evidence.json <<JSON
          {
            "pentest": {
              "provider": "Cobalt.io",
              "engagementId": "${ENG_ID}",
              "completedAt": "${NOW_TS}",
              "summary": { "totalFindings": 1, "critical": 0, "high": 0, "medium": 1, "low": 0 }
            }
          }
          JSON
          envsubst < pentest-evidence.template.md > pentest-evidence.md
          if jf evd create-evidence \
            --predicate pentest-evidence.json \
            --markdown pentest-evidence.md \
            --predicate-type "https://cobalt.io/evidence/pentest/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"; then
            PENTEST_EVIDENCE_STATUS=SUCCESS
          else
            PENTEST_EVIDENCE_STATUS=FAILED
          fi
          echo "PENTEST_EVIDENCE_STATUS=$PENTEST_EVIDENCE_STATUS" >> $GITHUB_ENV

          # Change approval predicate and markdown
          cat > change-approval.json <<JSON
          {
            "changeRequest": {
              "id": "${CHG_ID}",
              "status": "approved",
              "approvedBy": "${APPROVER}",
              "approvedAt": "${NOW_TS}",
              "environment": "STAGING"
            }
          }
          JSON
          envsubst < change-approval.template.md > change-approval.md
          if jf evd create-evidence \
            --predicate change-approval.json \
            --markdown change-approval.md \
            --predicate-type "https://servicenow.com/evidence/change-req/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}"; then
            CHANGEAPPROVAL_EVIDENCE_STATUS=SUCCESS
          else
            CHANGEAPPROVAL_EVIDENCE_STATUS=FAILED
          fi
          echo "CHANGEAPPROVAL_EVIDENCE_STATUS=$CHANGEAPPROVAL_EVIDENCE_STATUS" >> $GITHUB_ENV
          {
            echo "- STAGING evidence: IaC=${IAC_EVIDENCE_STATUS}, Pentest=${PENTEST_EVIDENCE_STATUS}, ChangeApproval=${CHANGEAPPROVAL_EVIDENCE_STATUS}"
          } >> "$PROMO_SUMMARY_FILE"

      - name: "[Release] PROD"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          # Only here do we set ALLOW_RELEASE=true. advance_one_step computes
          # that the next stage equals FINAL_STAGE (PROD) and calls
          # release_version(), which invokes the AppTrust Release API.
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          export JFROG_ADMIN_TOKEN="${{ secrets.JFROG_ADMIN_TOKEN }}"
          source .github/scripts/promote_lib.sh
          fetch_summary
          CURR_DISPLAY=$(display_stage_for "${CURRENT_STAGE:-}")
          echo "PROMO_RELEASE_EXPECTED=RELEASE to ${FINAL_STAGE}" >> $GITHUB_ENV
          if [[ "$CURR_DISPLAY" == "STAGING" ]]; then
            echo "PROMO_RELEASE_ATTEMPTED=true" >> $GITHUB_ENV
            ALLOW_RELEASE=true
            set +e
            advance_one_step
            RC=$?
            set -e
            fetch_summary
            REL_STATUS="${RELEASE_STATUS:-UNKNOWN}"
            STATUS="FAILED"
            case "$REL_STATUS" in
              RELEASED|TRUSTED_RELEASE|released|trusted_release) STATUS="SUCCESS" ;;
            esac
            if [[ "$RC" -ne 0 ]]; then STATUS="FAILED"; fi
            echo "PROMO_RELEASE_ACTUAL=${REL_STATUS}" >> $GITHUB_ENV
            echo "PROMO_RELEASE_STATUS=$STATUS" >> $GITHUB_ENV
            {
              echo "- PROD Release: should release; actual status ${REL_STATUS} ‚Äî ${STATUS}"
            } >> "$PROMO_SUMMARY_FILE"
          else
            echo "PROMO_RELEASE_ATTEMPTED=false" >> $GITHUB_ENV
            {
              echo "- PROD Release: skipped (current=${CURR_DISPLAY})"
            } >> "$PROMO_SUMMARY_FILE"
          fi

      - name: "[Tags] Enforce PROD 'latest' invariants"
        if: ${{ env.PROMO_RELEASE_STATUS == 'SUCCESS' }}
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          APP_KEY="$APPLICATION_KEY"
          VER="$APP_VERSION"
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          TOKEN='${{ secrets.JFROG_ADMIN_TOKEN }}'
          RESP=$(mktemp)
          code=$(curl -sS -L -o "$RESP" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions?limit=1000&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$code" -lt 200 || "$code" -ge 300 ]]; then
            echo "‚ùå Failed to list versions (HTTP $code)" >&2; cat "$RESP" || true; exit 1
          fi
          # Determine desired latest = SemVer max among PROD (RELEASED/TRUSTED_RELEASE)
          DESIRED=$(jq -r '[.versions[] | select((.release_status|tostring|ascii_upcase)=="RELEASED" or (.release_status|tostring|ascii_upcase)=="TRUSTED_RELEASE") | .version] | unique | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort_by(split(".")|map(tonumber)) | last // empty' "$RESP")
          if [[ -z "$DESIRED" ]]; then
            echo "‚ÑπÔ∏è No PROD versions found; clearing any existing 'latest' tags"
            mapfile -t PREV_LATEST < <(jq -r '.versions[] | select(.tag=="latest") | .version' "$RESP")
            for pv in "${PREV_LATEST[@]:-}"; do
              [ -z "$pv" ] && continue
              # Restore previous tag from property when available; else use version
              restore=$(jq -r --arg v "$pv" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
              printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
              curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$pv" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
            done
            rm -f "$RESP" body.json
            exit 0
          fi
          echo "Desired latest in PROD: $DESIRED"
          # Assign latest to DESIRED: back up current tag value first
          CURR_TAG=$(jq -r --arg v "$DESIRED" '.versions[] | select(.version==$v) | (.tag // "")' "$RESP")
          jq -n --arg ct "$CURR_TAG" '{tag:"latest", properties:{original_tag_before_latest:[$ct]}}' > body.json
          curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$DESIRED" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          # For any other version currently tagged latest, restore its original tag
          mapfile -t OTHERS < <(jq -r --arg v "$DESIRED" '.versions[] | select(.tag=="latest" and .version!=$v) | .version' "$RESP")
          for ov in "${OTHERS[@]:-}"; do
            [ -z "$ov" ] && continue
            restore=$(jq -r --arg v "$ov" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
            printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
            curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$ov" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          done
          rm -f "$RESP" body.json || true


      - name: "[Summary] Promotion"
        if: always()
        run: |
          set -euo pipefail
          # Prepare display stages
          CURRENT_DISPLAY="${CURRENT_STAGE_BEFORE:-UNASSIGNED}"
          CURRENT_DISPLAY="${CURRENT_DISPLAY#bookverse-}"
          TARGET_DISPLAY="${TARGET_NAME:-${FINAL_STAGE:-UNKNOWN}}"
          export CURRENT_DISPLAY TARGET_DISPLAY
          # Build lifecycle path that emphasizes CURRENT_DISPLAY ‚ûî TARGET_DISPLAY
          STAGES="${STAGES_STR:-DEV QA STAGING PROD}"
          IFS=' ' read -r -a STAGE_ARR <<< "$STAGES"
          idx_current=-1; idx_target=-1
          for i in "${!STAGE_ARR[@]}"; do
            if [[ "${STAGE_ARR[$i]}" == "$CURRENT_DISPLAY" ]]; then idx_current=$i; fi
            if [[ "${STAGE_ARR[$i]}" == "$TARGET_DISPLAY" ]]; then idx_target=$i; fi
          done
          pre=""; post=""; sep=""
          if [[ $idx_current -ge 0 && $idx_target -ge 0 ]]; then
            for ((j=0;j<idx_current;j++)); do
              if [[ -n "$pre" ]]; then sep=" ‚Üí "; else sep=""; fi
              pre+="$sep${STAGE_ARR[$j]}"
            done
            for ((j=idx_target+1;j<${#STAGE_ARR[@]};j++)); do
              if [[ -n "$post" ]]; then sep=" ‚Üí "; else sep=""; fi
              post+="$sep${STAGE_ARR[$j]}"
            done
            LC_PATH="${pre:+$pre ‚Üí }**${CURRENT_DISPLAY} ‚ûî ${TARGET_DISPLAY}**${post:+ ‚Üí $post}"
          else
            LC_PATH="$STAGES"
          fi
          # Determine OUTCOME
          OUTCOME="SUCCESS"
          for s in "${PROMO_UNASSIGNED_STATUS:-}" "${PROMO_DEV_STATUS:-}" "${PROMO_QA_STATUS:-}" "${PROMO_STAGING_STATUS:-}" "${PROMO_RELEASE_STATUS:-}"; do
            if [[ "$s" == "FAILED" ]]; then OUTCOME="FAILURE"; fi
          done
          if [[ "$OUTCOME" == "SUCCESS" ]]; then
            for s in "${IAC_EVIDENCE_STATUS:-}" "${PENTEST_EVIDENCE_STATUS:-}" "${CHANGEAPPROVAL_EVIDENCE_STATUS:-}"; do
              if [[ "$s" == "FAILED" ]]; then OUTCOME="WARNING"; fi
            done
          fi
          # Promotion method (best effort; default move)
          PROMOTION_METHOD="move"
          # Select template ID
          TID="1"
          # Generate ONLY the markdown summary via Node using the provided templates
          node - <<'NODE' | tee -a "$GITHUB_STEP_SUMMARY" >/dev/null
          (function(){
            function iconFor(status){
              switch ((status||'').toUpperCase()) {
                case 'SUCCESS': return '‚úÖ';
                case 'WARNING': return '‚ö†Ô∏è';
                case 'FAILURE': return '‚ùå';
                case 'FAILED': return '‚ùå';
                default: return '‚Äì';
              }
            }
            const env = process.env;
            const app = env.APPLICATION_KEY || '';
            const ver = env.APP_VERSION || '';
            const current = env.CURRENT_DISPLAY || '';
            const target = env.TARGET_DISPLAY || '';
            const lifecycleDefined = `UNASSIGNED ‚Üí ${(env.STAGES_STR || 'DEV QA STAGING PROD').split(' ').join(' ‚Üí ')}`;
            const lifecycleHighlight = env.LIFECYCLE_PATH || lifecycleDefined;
            const promoMethod = (env.PROMOTION_METHOD || 'move');

            // Step statuses (may be empty if skipped)
            const sUnassigned = (env.PROMO_UNASSIGNED_STATUS || '').toUpperCase();
            const sDev = (env.PROMO_DEV_STATUS || '').toUpperCase();
            const sQa = (env.PROMO_QA_STATUS || '').toUpperCase();
            const sStg = (env.PROMO_STAGING_STATUS || '').toUpperCase();
            const sRel = (env.PROMO_RELEASE_STATUS || '').toUpperCase();

            // Evidence statuses
            const evIac = (env.IAC_EVIDENCE_STATUS || '').toUpperCase();
            const evPentest = (env.PENTEST_EVIDENCE_STATUS || '').toUpperCase();
            const evChange = (env.CHANGEAPPROVAL_EVIDENCE_STATUS || '').toUpperCase();

            function stepOutcomeFromPlatform(stepStatus){
              const st = (stepStatus||'').toUpperCase();
              if (st === 'FAILED' || st === 'FAILURE') return 'FAILURE';
              if (!st) return 'SKIPPED';
              return 'SUCCESS';
            }

            function evidenceLine(name, status, hint){
              const up = (status||'').toUpperCase();
              if (up === 'FAILED') return `  - ‚ùå ${name} (failed)`;
              if (up === 'SUCCESS') return `  - ‚úÖ ${name}`;
              return `  - ${name} (${hint || 'not evaluated'})`;
            }

            function stepSection(from, to, kind, constraints, evidences, stepStatus){
              const promoResult = stepOutcomeFromPlatform(stepStatus);
              // A step can be SUCCESS even if evidence had failures; reflect that via step outcome
              const hasEvidenceFail = evidences.some(e => (e.status||'').toUpperCase() === 'FAILED');
              const stepOutcome = promoResult === 'FAILURE' ? 'FAILURE' : (hasEvidenceFail ? 'WARNING' : 'SUCCESS');
              const lines = [];
              lines.push(`### Step: ${from} ‚Üí ${to}`);
              lines.push(`- **Type:** ${kind}`);
              lines.push(`- **Constraints:** ${constraints || 'None'}`);
              lines.push(`- **Evidence Used:**`);
              if (!evidences.length) {
                lines.push(`  - (none)`);
              } else {
                evidences.forEach(e => lines.push(evidenceLine(e.name, e.status, e.hint)));
              }
              lines.push(`- **Promotion Result:** ${iconFor(promoResult)} ${promoResult}`);
              lines.push(`- **Step Outcome:** ${iconFor(stepOutcome)} ${stepOutcome}`);
              return { text: lines.join('\n'), outcome: stepOutcome };
            }

            // Executive Summary
            // Per-step sections with evidence
            const sec1 = stepSection('UNASSIGNED','DEV',`Promote (${promoMethod})`, 'None', [
              { name: 'SLSA Provenance (UNASSIGNED)', status: '', hint: 'attached in CI; not evaluated here' },
              { name: 'Jira Release Notes (UNASSIGNED)', status: '', hint: 'attached in CI; not evaluated here' },
            ], sUnassigned);
            const sec2 = stepSection('DEV','QA',`Promote (${promoMethod})`, 'None', [
              { name: 'Coverage (pytest) [Package]', status: '', hint: 'attached in CI; not evaluated here' },
              { name: 'SAST (Checkmarx) [Package]', status: '', hint: 'attached in CI; not evaluated here' },
            ], sDev);
            const sec3 = stepSection('QA','STAGING',`Promote (${promoMethod})`, 'None', [
              { name: 'DAST (Invicti)', status: '', hint: 'not configured in this workflow' },
              { name: 'API Tests (Postman)', status: '', hint: 'not configured in this workflow' },
            ], sQa);
            const sec4 = stepSection('STAGING','PROD',`Release (${promoMethod})`, 'None', [
              { name: 'Snyk IaC', status: evIac },
              { name: 'Cobalt Pentest', status: evPentest },
              { name: 'ServiceNow Change Approval', status: evChange },
            ], sRel);

            // Aggregate overall outcome: FAIL > WARNING > SUCCESS
            const outcomes = [sec1.outcome, sec2.outcome, sec3.outcome, sec4.outcome].filter(Boolean);
            let overall = 'SUCCESS';
            if (outcomes.some(o => o === 'FAILURE')) overall = 'FAILURE';
            else if (outcomes.some(o => o === 'WARNING')) overall = 'WARNING';

            const exec = [
              `### Executive Summary`,
              `- **Lifecycle:** ${lifecycleDefined}`,
              `- **Application:** ${app}`,
              `- **Version:** ${ver}`,
              `- **From ‚Üí To:** ${current} ‚Üí ${target}`,
              `- **Outcome:** ${iconFor(overall)} ${overall}`,
            ].join('\n');

            const report = [exec, '', sec1.text, '', sec2.text, '', sec3.text, '', sec4.text].join('\n');
            process.stdout.write(report);
          })();
          NODE
