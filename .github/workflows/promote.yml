name: Promote

on:
  workflow_dispatch:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: choice
        options: [ DEV, QA, STAGING, PROD ]
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string

jobs:
  promote:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve application and version
        run: |
          set -euo pipefail
          SERVICE_NAME=$(echo ${{ github.event.repository.name }} | sed 's/bookverse-//')
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          TARGET_STAGE=${{ inputs.target_stage }}
          APP_VERSION_INPUT="${{ inputs.application_version }}"
          APP_VERSION=""
          if [ -n "$APP_VERSION_INPUT" ]; then
            APP_VERSION="$APP_VERSION_INPUT"
          else
            echo "üîé Fetching latest application version for $APPLICATION_KEY"
            RESP_FILE=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_FILE" -w "%{http_code}" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?limit=1&order_by=created&order_asc=false" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "Accept: application/json")
            if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
              if LATEST_VERSION=$(jq -er '.versions[0].version // empty' "$RESP_FILE" 2>/dev/null); then
                APP_VERSION="$LATEST_VERSION"
              fi
            fi
            rm -f "$RESP_FILE"
            if [ -z "$APP_VERSION" ]; then
              echo "‚ùå Could not determine latest application version for $APPLICATION_KEY" >&2
              exit 1
            fi
          fi
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "TARGET_STAGE=$TARGET_STAGE" >> $GITHUB_ENV

      - name: Setup JFrog CLI (for evidence attachments)
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: github-bookverse-inventory
          disable-job-summary: true
          oidc-audience: jfrog-github

      - name: Prepare evidence signing keys (optional)
        run: |
          set -euo pipefail
          if [[ -n "${{ secrets.EVIDENCE_PRIVATE_KEY }}" ]]; then
            umask 077
            printf "%s" "${{ secrets.EVIDENCE_PRIVATE_KEY }}" > evidence_private.pem
            KEY_ALIAS="${{ vars.EVIDENCE_KEY_ALIAS || 'BookVerse-Evidence-Key' }}"
            echo "EVIDENCE_SIGN_ARGS=--key evidence_private.pem --key-alias ${KEY_ALIAS} --provider-id github-actions" >> $GITHUB_ENV
          else
            echo "EVIDENCE_SIGN_ARGS=" >> $GITHUB_ENV
          fi

      - name: Promote application version across SDLC to PROD (chain)
        run: |
          set -euo pipefail
          echo "üì¶ Application: $APPLICATION_KEY"
          echo "üè∑Ô∏è Version: $APP_VERSION"
          
          # Discover current stage and release status (robust fetch)
          SUMMARY_BODY=$(mktemp)
          SUMMARY_CODE=$(curl -sS -L -o "$SUMMARY_BODY" -w "%{http_code}" \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION?project=${{ vars.PROJECT_KEY }}" \
            -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -H "Accept: application/json")
          if [[ "$SUMMARY_CODE" -lt 200 || "$SUMMARY_CODE" -ge 300 ]]; then
            # Try with trailing slash
            SUMMARY_CODE=$(curl -sS -L -o "$SUMMARY_BODY" -w "%{http_code}" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/?project=${{ vars.PROJECT_KEY }}" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
              -H "Accept: application/json")
          fi
          if [[ "$SUMMARY_CODE" -lt 200 || "$SUMMARY_CODE" -ge 300 ]]; then
            # Fallback: list versions and pick the matching one
            LIST_BODY=$(mktemp)
            LIST_CODE=$(curl -sS -L -o "$LIST_BODY" -w "%{http_code}" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions?project=${{ vars.PROJECT_KEY }}&limit=100&order_by=created&order_asc=false" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
              -H "Accept: application/json")
            if [[ "$LIST_CODE" -ge 200 && "$LIST_CODE" -lt 300 ]]; then
              MATCH=$(jq -c --arg v "$APP_VERSION" '.versions[]? | select(.version == $v)' "$LIST_BODY" 2>/dev/null || echo '')
              if [[ -n "$MATCH" ]]; then
                printf '%s' "$MATCH" > "$SUMMARY_BODY"
                SUMMARY_CODE=200
              fi
            fi
            rm -f "$LIST_BODY"
          fi
          if [[ "$SUMMARY_CODE" -lt 200 || "$SUMMARY_CODE" -ge 300 ]]; then
            echo "‚ùå Failed to fetch version summary (HTTP $SUMMARY_CODE)" >&2
            cat "$SUMMARY_BODY" || true
            rm -f "$SUMMARY_BODY"
            exit 1
          fi
          CURRENT_STAGE=$(jq -r '.current_stage // empty' "$SUMMARY_BODY" 2>/dev/null || echo "")
          RELEASE_STATUS=$(jq -r '.release_status // empty' "$SUMMARY_BODY" 2>/dev/null || echo "")
          rm -f "$SUMMARY_BODY"
          CS_UPPER=$(echo "$CURRENT_STAGE" | tr '[:lower:]' '[:upper:]')
          echo "üîé Current stage: ${CURRENT_STAGE:-UNASSIGNED} (release_status=${RELEASE_STATUS:-unknown})"
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE:-UNASSIGNED}" >> $GITHUB_ENV
          echo "RELEASE_STATUS_BEFORE=${RELEASE_STATUS:-UNKNOWN}" >> $GITHUB_ENV
          
          # Resolve lifecycle order dynamically (bookverse-lifecycle by default)
          LIFECYCLE_NAME="${{ vars.LIFECYCLE_NAME || 'bookverse-lifecycle' }}"
          LC_FILE=$(mktemp)
          # Try multiple endpoints to resolve lifecycle stages
          PROBED=false
          for URL in \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/lifecycles/$LIFECYCLE_NAME" \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/projects/${{ vars.PROJECT_KEY }}/lifecycles/$LIFECYCLE_NAME" \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/lifecycle"; do
            CODE=$(curl -sS -L -o "$LC_FILE" -w "%{http_code}" "$URL" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
              -H "Accept: application/json" || echo 000)
            if [[ "$CODE" -ge 200 && "$CODE" -lt 300 ]]; then PROBED=true; break; fi
          done
          # Extract stage names in order, robust to schema differences
          NAMES=$(jq -r '
            if .stages then (.stages[] | if type=="object" then .name else . end)
            elif .lifecycle and .lifecycle.stages then (.lifecycle.stages[] | if type=="object" then .name else . end)
            elif type=="array" then (.[] | if type=="object" then .name else . end)
            else empty end' "$LC_FILE" 2>/dev/null || true)
          rm -f "$LC_FILE"
          STAGES=()
          while IFS= read -r line; do [[ -n "$line" ]] && STAGES+=("$line"); done < <(printf "%s\n" "$NAMES")
          if [[ ${#STAGES[@]} -eq 0 ]]; then
            # Fallback lifecycle
            STAGES=(DEV QA STAGING PROD)
          fi
          # Compute indices
          CURRENT_INDEX=-1
          for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]^^}" == "$CS_UPPER" ]]; then CURRENT_INDEX=$i; break; fi; done
          TS_INPUT="${{ inputs.target_stage }}"
          TARGET_NAME="$TS_INPUT"
          if [[ -z "$TARGET_NAME" ]]; then TARGET_NAME="${STAGES[-1]}"; fi
          TARGET_UPPER=$(echo "$TARGET_NAME" | tr '[:lower:]' '[:upper:]')
          TARGET_INDEX=-1
          for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]^^}" == "$TARGET_UPPER" ]]; then TARGET_INDEX=$i; break; fi; done
          if [[ "$TARGET_INDEX" -lt 0 ]]; then TARGET_INDEX=$((${#STAGES[@]}-1)); fi
          # If current unknown/unassigned, start before first stage
          if [[ "$CURRENT_INDEX" -lt 0 ]]; then CURRENT_INDEX=-1; fi
          if [[ "$CURRENT_INDEX" -ge "$TARGET_INDEX" ]]; then
            echo "‚ÑπÔ∏è Current stage ($CS_UPPER) is at or beyond target ($TARGET_UPPER). Nothing to promote."
            echo "PROMOTED_STAGES=" >> $GITHUB_ENV
            echo "DID_RELEASE=false" >> $GITHUB_ENV
            exit 0
          fi
          
          PROMOTED_STAGES=""
          DID_RELEASE=false
          
          fetch_summary() {
            local body
            body=$(mktemp)
            local code
            code=$(curl -sS -L -o "$body" -w "%{http_code}" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION?project=${{ vars.PROJECT_KEY }}" \
              -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
              -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
              -H "Accept: application/json")
            if [[ "$code" -lt 200 || "$code" -ge 300 ]]; then
              code=$(curl -sS -L -o "$body" -w "%{http_code}" \
                "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/?project=${{ vars.PROJECT_KEY }}" \
                -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
                -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
                -H "Accept: application/json")
            fi
            if [[ "$code" -ge 200 && "$code" -lt 300 ]]; then
              CURRENT_STAGE=$(jq -r '.current_stage // empty' "$body" 2>/dev/null || echo "")
              RELEASE_STATUS=$(jq -r '.release_status // empty' "$body" 2>/dev/null || echo "")
            fi
            rm -f "$body"
            CS_UPPER=$(echo "$CURRENT_STAGE" | tr '[:lower:]' '[:upper:]')
            echo "üîé Current stage: ${CURRENT_STAGE:-UNASSIGNED} (release_status=${RELEASE_STATUS:-unknown})"
          }

          # Iteratively promote/release to next stage, refetching state each hop
          fetch_summary
          while true; do
            # Compute current and target indices each iteration
            CURRENT_INDEX=-1
            for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]^^}" == "$CS_UPPER" ]]; then CURRENT_INDEX=$i; break; fi; done
            if [[ "$CURRENT_INDEX" -lt 0 ]]; then CURRENT_INDEX=-1; fi
            # Recompute target index (may be unchanged)
            TARGET_UPPER=$(echo "$TARGET_NAME" | tr '[:lower:]' '[:upper:]')
            TARGET_INDEX=-1
            for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]^^}" == "$TARGET_UPPER" ]]; then TARGET_INDEX=$i; break; fi; done
            if [[ "$TARGET_INDEX" -lt 0 ]]; then TARGET_INDEX=$((${#STAGES[@]}-1)); fi
            NEXT_INDEX=$((CURRENT_INDEX+1))
            if [[ "$NEXT_INDEX" -gt "$TARGET_INDEX" ]]; then break; fi
            STG="${STAGES[$NEXT_INDEX]}"
            if [[ "${STG^^}" =~ ^PROD ]]; then
              echo "üöÄ Releasing to PROD via AppTrust Release API"
              RESP_BODY=$(mktemp)
              HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
                "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/release?async=false" \
                -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
                -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
                -H "Content-Type: application/json" \
                -H "Accept: application/json" \
                -d '{"promotion_type":"copy"}')
              echo "HTTP $HTTP_STATUS"; cat "$RESP_BODY" || true; echo
              rm -f "$RESP_BODY"
              if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
                echo "‚ùå Release to PROD failed" >&2
                exit 1
              fi
              DID_RELEASE=true
              PROMOTED_STAGES="$PROMOTED_STAGES${PROMOTED_STAGES:+ }PROD"
              fetch_summary
            else
              echo "üöÄ Promoting to $STG via AppTrust"
              RESP_BODY=$(mktemp)
              HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
                "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/promote?async=false" \
                -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
                -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
                -H "Content-Type: application/json" \
                -H "Accept: application/json" \
                -d "{\"target_stage\": \"$STG\", \"promotion_type\": \"copy\"}")
              echo "HTTP $HTTP_STATUS"; cat "$RESP_BODY" || true; echo
              # Handle 400 same-as-current gracefully by refetching and continuing
              if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
                PROMOTED_STAGES="$PROMOTED_STAGES${PROMOTED_STAGES:+ }$STG"
                rm -f "$RESP_BODY"
                fetch_summary
              else
                if grep -q "same as current stage" "$RESP_BODY" 2>/dev/null; then
                  echo "‚ÑπÔ∏è Server reports current is already $STG; refetching and continuing"
                  rm -f "$RESP_BODY"
                  fetch_summary
                else
                  rm -f "$RESP_BODY"
                  echo "‚ùå Promotion to $STG failed" >&2
                  exit 1
                fi
              fi
            fi
          done
          echo "PROMOTED_STAGES=$PROMOTED_STAGES" >> $GITHUB_ENV
          echo "DID_RELEASE=$DID_RELEASE" >> $GITHUB_ENV

      - name: Attach QA gate evidence (Invicti DAST, Postman API) if in QA
        run: |
          set -euo pipefail
          # Determine if QA was reached in this run
          REACHED_QA=false
          if echo "${PROMOTED_STAGES:-}" | grep -qw QA; then REACHED_QA=true; fi
          if [[ "$REACHED_QA" != true ]]; then
            echo "‚ÑπÔ∏è QA not reached; skipping QA gate evidence"
            exit 0
          fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          # Invicti DAST (QA)
          SCAN_ID=$(cat /proc/sys/kernel/random/uuid)
          MED=$((2 + RANDOM % 5))
          cat <<EOF > dast-qa.json
          {
            "environment": "QA",
            "scanId": "${SCAN_ID}",
            "status": "PASSED",
            "findings": { "critical": 0, "high": 0, "medium": ${MED} },
            "attachStage": "QA", "gateForPromotionTo": "STAGING",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate dast-qa.json \
            --predicate-type "https://invicti.com/evidence/dast/v3" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è DAST (QA) attachment failed"
          # Postman API (QA)
          COLL=$(cat /proc/sys/kernel/random/uuid)
          PASS=$((100 + RANDOM % 31))
          cat <<EOF > postman-qa.json
          {
            "environment": "QA",
            "collectionId": "${COLL}",
            "status": "PASSED",
            "assertionsPassed": ${PASS},
            "assertionsFailed": 0,
            "attachStage": "QA", "gateForPromotionTo": "STAGING",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate postman-qa.json \
            --predicate-type "https://postman.com/evidence/collection/v2.2" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è Postman (QA) attachment failed"

      - name: Attach STAGING gate evidence (Snyk IaC, Cobalt, ServiceNow) if in STAGING
        run: |
          set -euo pipefail
          REACHED_STAGING=false
          if echo "${PROMOTED_STAGES:-}" | grep -qw STAGING; then REACHED_STAGING=true; fi
          if [[ "$REACHED_STAGING" != true ]]; then
            echo "‚ÑπÔ∏è STAGING not reached; skipping STAGING gate evidence"
            exit 0
          fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          # Snyk IaC (STAGING)
          MED=$((1 + RANDOM % 3)); LOW=$((8 + RANDOM % 7))
          cat <<EOF > iac-staging.json
          {
            "environment": "STAGING", "status": "PASSED",
            "misconfigurations": { "high": 0, "medium": ${MED}, "low": ${LOW} },
            "attachStage": "STAGING", "gateForPromotionTo": "PROD",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate iac-staging.json \
            --predicate-type "https://snyk.io/evidence/iac/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è IaC (STAGING) attachment failed"
          # Cobalt Pentest (STAGING)
          PENT=$(cat /proc/sys/kernel/random/uuid)
          cat <<EOF > pentest-staging.json
          {
            "environment": "STAGING", "pentestId": "${PENT}",
            "status": "COMPLETED", "summary": "No critical/high. Medium/low scheduled for remediation.",
            "attachStage": "STAGING", "gateForPromotionTo": "PROD",
            "timestamp": "${NOW_TS}"
          }
          EOF
          jf evd create \
            --predicate pentest-staging.json \
            --predicate-type "https://cobalt.io/evidence/pentest/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è Pentest (STAGING) attachment failed"
          # ServiceNow change approval (STAGING gate to PROD)
          TID=$((3000000 + RANDOM % 1000000))
          cat <<EOF > servicenow-approval.json
          {
            "environment": "PROD",
            "ticketId": "CHG${TID}",
            "status": "APPROVED",
            "approvedBy": "change-manager-${RANDOM}",
            "approvalTimestamp": "${NOW_TS}",
            "attachStage": "STAGING", "gateForPromotionTo": "PROD"
          }
          EOF
          jf evd create \
            --predicate servicenow-approval.json \
            --predicate-type "https://servicenow.com/evidence/change-request/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è ServiceNow approval attachment failed"

      - name: Attach ArgoCD deployment evidence (PROD verification) if released
        run: |
          set -euo pipefail
          if [[ "${DID_RELEASE}" != "true" ]]; then
            echo "‚ÑπÔ∏è Not released in this run; skipping ArgoCD PROD verification"
            exit 0
          fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          REV="${{ github.sha }}"; SHORT=${REV:0:8}
          cat <<EOF > argocd-prod.json
          { "tool": "ArgoCD", "status": "Synced", "revision": "${SHORT}", "deployedAt": "${NOW_TS}", "attachStage": "PROD" }
          EOF
          jf evd create \
            --predicate argocd-prod.json \
            --predicate-type "https://argoproj.github.io/argo-cd/evidence/deployment/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "${{ vars.PROJECT_KEY }}" $EVIDENCE_SIGN_ARGS || echo "‚ö†Ô∏è ArgoCD PROD verification attachment failed"

      - name: Generate promotion summary
        run: |
          echo "## üöÄ AppTrust Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìÑ Evidence Plan: see bookverse-demo-init/docs/EVIDENCE_PLAN.md" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** $APPLICATION_KEY" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $APP_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Started at:** ${CURRENT_STAGE_BEFORE}" >> $GITHUB_STEP_SUMMARY
          echo "**Promoted stages:** ${PROMOTED_STAGES:-none}" >> $GITHUB_STEP_SUMMARY
          echo "**Released to PROD:** ${DID_RELEASE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Promotions flow: UNASSIGNED ‚Üí DEV ‚Üí QA ‚Üí STAGING ‚Üí (Release) PROD" >> $GITHUB_STEP_SUMMARY


