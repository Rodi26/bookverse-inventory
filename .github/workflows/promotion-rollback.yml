name: Promotion Rollback

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version (SemVer) to rollback (omit to use latest promoted)"
        required: false
        type: string
      DEMO_MODE:
        description: 'Enable demo mode (verbose logs, request tracing)'
        required: false
        default: 'false'
        type: choice
        options: ['false', 'true']

concurrency:
  group: promotion-rollback-${{ github.event.repository.name }}
  cancel-in-progress: false

jobs:
  rollback:
    name: Rollback ${{ github.event.repository.name }} ${{ inputs.version || 'latest-promoted' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Apply DEMO_MODE settings
        if: ${{ inputs.DEMO_MODE == 'true' || env.DEMO_MODE == 'true' }}
        run: |
          echo "🔔 DEMO_MODE enabled"
          echo "ACTIONS_STEP_DEBUG=true" >> $GITHUB_ENV
          echo "ACTIONS_RUNNER_DEBUG=true" >> $GITHUB_ENV
          echo "HTTP_DEBUG_LEVEL=verbose" >> $GITHUB_ENV
          echo "BASH_XTRACE_ENABLED=1" >> $GITHUB_ENV

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Execute rollback
        shell: bash
        env:
          APPTRUST_BASE_URL: ${{ vars.JFROG_URL }}/apptrust/api/v1
          APPTRUST_ACCESS_TOKEN: ${{ secrets.JFROG_ADMIN_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${APPTRUST_BASE_URL:-}" ]; then
            echo "Missing vars.JFROG_URL to derive APPTRUST_BASE_URL" >&2
            exit 2
          fi
          if [ -z "${APPTRUST_ACCESS_TOKEN:-}" ]; then
            echo "Missing secret JFROG_ADMIN_TOKEN" >&2
            exit 2
          fi

          # Derive application key from repo name (e.g., bookverse-inventory -> bookverse-inventory)
          SERVICE_NAME=$(echo "${GITHUB_REPOSITORY#*/}" | sed 's/bookverse-//')
          APP_KEY="bookverse-$SERVICE_NAME"

          # Determine target version: use input if provided, else resolve latest promoted
          TARGET_VERSION="${{ inputs.version || '' }}"
          if [ -z "$TARGET_VERSION" ]; then
            echo "🔎 Resolving latest promoted version for $APP_KEY"
            RESP_FILE=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_FILE" -w "%{http_code}" \
              "$APPTRUST_BASE_URL/applications/$APP_KEY/versions?limit=20&order_by=created&order_asc=false" \
              -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
              -H "Accept: application/json")
            if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
              TARGET_VERSION=$(jq -r '.versions[] | select(.release_status == "RELEASED" or .release_status == "TRUSTED_RELEASE") | .version' "$RESP_FILE" | head -n1)
            fi
            rm -f "$RESP_FILE"
            if [ -z "${TARGET_VERSION:-}" ] || [ "$TARGET_VERSION" = "null" ]; then
              echo "❌ Could not resolve latest promoted version for $APP_KEY" >&2
              exit 1
            fi
            echo "🎯 Defaulting to latest promoted version: $TARGET_VERSION"
          fi

          # Snapshot BEFORE state
          SNAP_BEFORE=$(mktemp)
          curl -sS -L -o "$SNAP_BEFORE" -w "" \
            "$APPTRUST_BASE_URL/applications/$APP_KEY/versions?limit=50&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
            -H "Accept: application/json"
          BEFORE_LATEST=$(jq -r '.versions[] | select((.release_status=="RELEASED" or .release_status=="TRUSTED_RELEASE") and (.tag=="latest")) | .version' "$SNAP_BEFORE" | head -n1)
          TARGET_TAG_BEFORE=$(jq -r --arg ver "$TARGET_VERSION" '.versions[] | select(.version==$ver) | (.tag // "")' "$SNAP_BEFORE" 2>/dev/null || echo "")
          HAD_LATEST_BEFORE=false
          if [ "$TARGET_TAG_BEFORE" = "latest" ]; then HAD_LATEST_BEFORE=true; fi
          rm -f "$SNAP_BEFORE"

          STATUS="SUCCESS"
          MSG=""
          if python3 .github/scripts/apptrust_rollback.py \
            --app "$APP_KEY" \
            --version "$TARGET_VERSION"; then
            MSG="Rollback executed for $APP_KEY@$TARGET_VERSION"
          else
            STATUS="FAILED"
            MSG="Rollback failed for $APP_KEY@$TARGET_VERSION"
          fi

          # Snapshot AFTER state and validate outcome
          SNAP_AFTER=$(mktemp)
          curl -sS -L -o "$SNAP_AFTER" -w "" \
            "$APPTRUST_BASE_URL/applications/$APP_KEY/versions?limit=50&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
            -H "Accept: application/json"
          AFTER_LATEST=$(jq -r '.versions[] | select((.release_status=="RELEASED" or .release_status=="TRUSTED_RELEASE") and (.tag=="latest")) | .version' "$SNAP_AFTER" | head -n1)
          TARGET_TAG_AFTER=$(jq -r --arg ver "$TARGET_VERSION" '.versions[] | select(.version==$ver) | (.tag // "")' "$SNAP_AFTER" 2>/dev/null || echo "")
          rm -f "$SNAP_AFTER"

          VALIDATION_ERRORS=()
          if [ "$TARGET_TAG_AFTER" != "quarantine" ]; then
            VALIDATION_ERRORS+=("Target tag not 'quarantine' (got '$TARGET_TAG_AFTER')")
          fi
          if [ "$HAD_LATEST_BEFORE" = "true" ]; then
            if [ -z "${AFTER_LATEST}" ] || [ "$AFTER_LATEST" = "$TARGET_VERSION" ]; then
              VALIDATION_ERRORS+=("'latest' did not move away from target")
            fi
          fi

          # If we had latest before (or we have a candidate after), ensure PROD 'current_stage' reflects rollback by releasing candidate to PROD
          CANDIDATE_VERSION="${AFTER_LATEST:-}"
          if [ -n "$CANDIDATE_VERSION" ] && [ "$CANDIDATE_VERSION" != "$TARGET_VERSION" ]; then
            SERVICE_NAME=${SERVICE_NAME:-$(echo "${GITHUB_REPOSITORY#*/}" | sed 's/bookverse-//')}
            PROJECT_KEY="${{ vars.PROJECT_KEY }}"
            REPO_DOCKER="${PROJECT_KEY}-${SERVICE_NAME}-docker-release-local"
            REPO_PYTHON="${PROJECT_KEY}-${SERVICE_NAME}-python-release-local"
            RELEASE_PAYLOAD=$(printf '{"promotion_type":"move","included_repository_keys":["%s","%s"]}' "$REPO_DOCKER" "$REPO_PYTHON")
            RESP_BODY=$(mktemp)
            HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
              "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$CANDIDATE_VERSION/release?async=false" \
              -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "$RELEASE_PAYLOAD")
            if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
              VALIDATION_ERRORS+=("Release candidate to PROD failed (HTTP $HTTP_STATUS)")
            fi
            rm -f "$RESP_BODY"
          fi

          # Fetch content summaries for precise current_stage validation
          CONTENT_TARGET=$(mktemp)
          CODE_T=$(curl -sS -L -o "$CONTENT_TARGET" -w "%{http_code}" \
            "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$TARGET_VERSION/content" \
            -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
            -H "Accept: application/json" || echo 000)
          CURR_STAGE_TARGET=""
          if [[ "$CODE_T" -ge 200 && "$CODE_T" -lt 300 ]]; then
            CURR_STAGE_TARGET=$(jq -r '.current_stage // empty' "$CONTENT_TARGET" 2>/dev/null || echo "")
          fi
          rm -f "$CONTENT_TARGET"

          CURR_STAGE_CAND=""
          if [ -n "$CANDIDATE_VERSION" ]; then
            CONTENT_CAND=$(mktemp)
            CODE_C=$(curl -sS -L -o "$CONTENT_CAND" -w "%{http_code}" \
              "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$CANDIDATE_VERSION/content" \
              -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
              -H "Accept: application/json" || echo 000)
            if [[ "$CODE_C" -ge 200 && "$CODE_C" -lt 300 ]]; then
              CURR_STAGE_CAND=$(jq -r '.current_stage // empty' "$CONTENT_CAND" 2>/dev/null || echo "")
            fi
            rm -f "$CONTENT_CAND"
          fi

          # Validate stage expectations: target not PROD; candidate is PROD (if candidate exists)
          if [ -n "$CURR_STAGE_TARGET" ] && [ "$CURR_STAGE_TARGET" = "PROD" ]; then
            VALIDATION_ERRORS+=("Target still at current_stage=PROD")
          fi
          if [ -n "$CANDIDATE_VERSION" ]; then
            if [ -z "$CURR_STAGE_CAND" ] || [ "$CURR_STAGE_CAND" != "PROD" ]; then
              VALIDATION_ERRORS+=("Candidate not at current_stage=PROD (got '${CURR_STAGE_CAND:-empty}')")
            fi
          fi

          # Finalize validation status after all checks
          if [ ${#VALIDATION_ERRORS[@]} -gt 0 ]; then
            STATUS="FAILED"
            MSG="Validation failed: ${VALIDATION_ERRORS[*]}"
          fi

          # If target is still at PROD, attempt a demotion to STAGING via Promote API
          if [ "${CURR_STAGE_TARGET:-}" = "PROD" ]; then
            PROJECT_KEY="${{ vars.PROJECT_KEY }}"
            API_STAGE="${PROJECT_KEY}-STAGING"
            DEMOTE_BODY=$(printf '{"target_stage":"%s","promotion_type":"move"}' "$API_STAGE")
            DEMOTE_RESP=$(mktemp)
            DEMOTE_CODE=$(curl -sS -L -o "$DEMOTE_RESP" -w "%{http_code}" -X POST \
              "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$TARGET_VERSION/promote?async=false" \
              -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "$DEMOTE_BODY")
            if [[ "$DEMOTE_CODE" -lt 200 || "$DEMOTE_CODE" -ge 300 ]]; then
              VALIDATION_ERRORS+=("Demote to STAGING failed (HTTP $DEMOTE_CODE)")
            fi
            rm -f "$DEMOTE_RESP"
            # Re-fetch target stage post demotion attempt
            CONTENT_TARGET2=$(mktemp)
            CODE_T2=$(curl -sS -L -o "$CONTENT_TARGET2" -w "%{http_code}" \
              "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$TARGET_VERSION/content" \
              -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
              -H "Accept: application/json" || echo 000)
            if [[ "$CODE_T2" -ge 200 && "$CODE_T2" -lt 300 ]]; then
              CURR_STAGE_TARGET=$(jq -r '.current_stage // empty' "$CONTENT_TARGET2" 2>/dev/null || echo "")
            fi
            rm -f "$CONTENT_TARGET2"
            if [ "${CURR_STAGE_TARGET:-}" = "PROD" ]; then
              VALIDATION_ERRORS+=("Target remained at current_stage=PROD after demotion attempt")
            fi
          fi
          if [ ${#VALIDATION_ERRORS[@]} -gt 0 ]; then
            STATUS="FAILED"
            MSG="Validation failed: ${VALIDATION_ERRORS[*]}"
          fi

          {
            echo "## 🔄 Promotion Rollback"
            echo ""
            echo "**Repository:** \`${{ github.repository }}\`"
            echo "**Application:** \`$APP_KEY\`"
            echo "**Target Version:** \`$TARGET_VERSION\`"
            echo "**Status:** ${STATUS}"
            echo ""
            echo "### Details"
            echo "- Triggered by: \`${{ github.actor }}\`"
            echo "- Workflow run: \`${{ github.run_id }}\` (attempt \`${{ github.run_attempt }}\`)"
            echo "- Timestamp (UTC): \`$(date -u +%Y-%m-%dT%H:%M:%SZ)\`"
            echo ""
            echo "### Validation"
            echo "- Before latest (PROD): \`${BEFORE_LATEST:-none}\`"
            echo "- After  latest (PROD): \`${AFTER_LATEST:-none}\`"
            echo "- Target tag before → after: \`${TARGET_TAG_BEFORE:-}\` → \`${TARGET_TAG_AFTER:-}\`"
            echo "- Target current_stage after: \`${CURR_STAGE_TARGET:-unknown}\`"
            if [ -n "$CANDIDATE_VERSION" ]; then
              echo "- Candidate current_stage after: \`${CURR_STAGE_CAND:-unknown}\`"
            fi
            if [ "${#VALIDATION_ERRORS[@]}" -gt 0 ]; then
              echo "- Result: ❌ ${MSG}"
            else
              echo "- Result: ✅ Rollback validated"
            fi
            echo ""
            echo "${MSG}"
          } >> "$GITHUB_STEP_SUMMARY"

          # Fail the job if validation failed
          if [ "$STATUS" = "FAILED" ]; then
            echo "${MSG}" >&2
            exit 1
          fi
